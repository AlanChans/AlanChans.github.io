<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>中单打野我都行</title>
  
  <subtitle>为中华崛起而读书</subtitle>
  <link href="http://alanchans.github.io/atom.xml" rel="self"/>
  
  <link href="http://alanchans.github.io/"/>
  <updated>2021-06-25T12:32:18.662Z</updated>
  <id>http://alanchans.github.io/</id>
  
  <author>
    <name>AlanChan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux下线程的使用</title>
    <link href="http://alanchans.github.io/2021/06/25/linuxPthread/"/>
    <id>http://alanchans.github.io/2021/06/25/linuxPthread/</id>
    <published>2021-06-25T12:29:54.000Z</published>
    <updated>2021-06-25T12:32:18.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下线程的使用"><a href="#Linux下线程的使用" class="headerlink" title="Linux下线程的使用"></a>Linux下线程的使用</h1><h2 id="1、Linux线程"><a href="#1、Linux线程" class="headerlink" title="1、Linux线程"></a>1、Linux线程</h2><ul><li><p>在早期的类Unix系统中是没有“线程”概念的，这是后面需求的才延伸出来的，它借助了进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。在Linux环境下的线程本质上还是进程，属于轻量级的进程（LWP：light weight process）。</p></li><li><p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。</p></li><li>fork复制对方的地址空间，产生一个“进程”；pthread_create共享对方的地址空间，就产生一个“线程”。</li></ul><h2 id="2、Linux线程创建"><a href="#2、Linux线程创建" class="headerlink" title="2、Linux线程创建"></a>2、Linux线程创建</h2><blockquote><p>使用下面所有的线程相关函数都必须做的工作：</p><p>1、包含头文件  #include <pthread.h></p><p>2、编译时链接线程库(线程库的名字叫pthread, 全名: libpthread.so libptread.a) -pthread</p></blockquote><h3 id="2-1获取线程ID（对应进程中-getpid-函数）"><a href="#2-1获取线程ID（对应进程中-getpid-函数）" class="headerlink" title="2.1获取线程ID（对应进程中 getpid() 函数）"></a>2.1获取线程ID（对应进程中 getpid() 函数）</h3><p>每一个线程都对应一个唯一的线程 ID（两个进程间，线程ID允许相同），ID 类型为 pthread_t，这个 ID 是一个无符号长整形数(%lu)，如果想要获取当前线程的线程 ID，可以调用如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 返回当前线程的线程ID，man说这个函数总会执行成功</span></span><br></pre></td></tr></table></figure><h3 id="2-2创建线程函数（对应进程中fork-函数）"><a href="#2-2创建线程函数（对应进程中fork-函数）" class="headerlink" title="2.2创建线程函数（对应进程中fork() 函数）"></a>2.2创建线程函数（对应进程中fork() 函数）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数：</p><ul><li>thread：传出参数，创建成功时保存系统为我们分配好的线程ID。</li><li>attr：通常传NULL，表示使用线程默认属性。也可自行修改。</li><li>start_routine：函数指针，指向线程任务函数(线程体)，该函数运行结束，则线程结束。该函数在子线程中执行。</li><li>arg：通过它把需要传递的参数传递到start_routine指向的函数体内部，如要传多个参数, 可以用结构封装。</li></ul></li><li><p>返回值：成功返回0； 失败返回错误号。具体错误可通过strerror()函数输出。</p></li></ul><h3 id="2-3实例"><a href="#2-3实例" class="headerlink" title="2.3实例"></a>2.3实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_pthread_create.c </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mytask</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子线程：i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程TID：%ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test</span> * <span class="title">pt</span> =</span> (struct Test *)arg;</span><br><span class="line">    pt-&gt;num = <span class="number">1000</span>;</span><br><span class="line">    pt-&gt;age = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">test</span>;</span></span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, mytask, &amp;test);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程TID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主线程TID：%ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令编译程序，<code>-lpthread</code>的意思是链接<code>pthread</code>线程库，要用线程相关函数除了包含头文件<code>#include &lt;pthread.h&gt;</code>以外，编译的时候还得指定链接线程库，否则编译失败。<code>-o app</code>的意思是指定输出的可执行文件名为<code>app</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc my_pthread_create.c -lpthread -o app</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# gcc my_pthread_create.c -lpthread -o app</span><br><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ls</span><br><span class="line">app  my_pthread_create.c</span><br><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ./app </span><br><span class="line">子线程创建成功, 线程TID: 139769949230848</span><br><span class="line">主线程TID：139769949235008</span><br><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article#</span><br></pre></td></tr></table></figure><p>编译执行后发现子线程虽然创建成功，但是子线程任务函数里面的打印并没有输出，原因是：</p><p>主线程一直在运行，执行期间创建出了子线程，接下来主线程和子线程“并发”，分道扬镳，各自执行自己的函数。子线程刚被创建出来，需要去抢CPU时间片，抢到了CPU时间片子线程的任务函数才能运行。</p><p>很明显，此时此刻，子线程并没有抢到CPU时间片，而主线程却抢到了。然后主线程去执行printf，执行完后发现没有工作要做了就直接返回退出了。</p><p>但主线程退出了, 虚拟地址空间就被释放了, 子线程就一并被销毁了，这样子线程任务函数里的printf就肯定没法运行了。</p><h2 id="3、Linux线程退出"><a href="#3、Linux线程退出" class="headerlink" title="3、Linux线程退出"></a>3、Linux线程退出</h2><p>在多线程进程中，要让主线程退出不导致虚拟地址空间的释放，剩下的子线程继续正常运行，可以在主线程中调用线程退出函数。线程退出函数会让当前线程马上退出，而且不会释放虚拟地址空间，不会影响到其他线程的正常运行。线程退出函数可以在子线程或者主线程中都使用。</p><h3 id="3-1线程退出函数"><a href="#3-1线程退出函数" class="headerlink" title="3.1线程退出函数"></a>3.1线程退出函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为 NULL。一般使用的这个线程退出带出数据的功能的时候，需要在线程创建的时候把一块堆内存的指针传进去。</li></ul><h3 id="3-2实例"><a href="#3-2实例" class="headerlink" title="3.2实例"></a>3.2实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mytask</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子线程：i = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 直接退出子线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程TID：%ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test</span> * <span class="title">pt</span> =</span> (struct Test *)arg;</span><br><span class="line">    pt-&gt;num = <span class="number">1000</span>;</span><br><span class="line">    pt-&gt;age = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">test</span>;</span></span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, mytask, &amp;test);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程TID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主线程TID：%ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 主线程退出，不会释放虚拟地址空间，不影响子线程运行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# gcc my_pthread_create.c -lpthread -o app</span><br><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ./app </span><br><span class="line">子线程创建成功, 线程TID: 139901666547456</span><br><span class="line">主线程TID：139901666551616</span><br><span class="line">子线程：i = 0</span><br><span class="line">子线程：i = 1</span><br><span class="line">子线程：i = 2</span><br><span class="line">子线程：i = 3</span><br><span class="line">子线程：i = 4</span><br><span class="line">子线程：i = 5</span><br><span class="line">子线程：i = 6</span><br><span class="line">子线程：i = 7</span><br><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# </span><br></pre></td></tr></table></figure><p>上面的程序执行结果说明，主线程执行<code>printf</code>就先退出了，此时虚拟地址空间还没有被释放，子线程继续执行<code>printf</code>，直到子线程执行到<code>pthread_exit</code>子线程就退出了，然后虚拟地址空间被释放，进程退出。</p><h2 id="4、Linux线程回收"><a href="#4、Linux线程回收" class="headerlink" title="4、Linux线程回收"></a>4、Linux线程回收</h2><p>子线程在一般情况下都是由主线程创建并启动的，如果子线程相对主线程而言要进行大量的耗时的运算，那么主线程就会先于子线程结束，就好比如<code>3.2实例</code>。但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束线程和进程，这种情况该怎么处理呢？</p><p>这就是线程回收函数 <code>pthread_join</code>的应用场景了，这个函数是一个阻塞函数，如果子线程还在运行，该函数就会一直阻塞，子线程退出函数解除阻塞进行资源的回收。函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p><h3 id="4-1线程回收函数（对应进程中-waitpid-函数）"><a href="#4-1线程回收函数（对应进程中-waitpid-函数）" class="headerlink" title="4.1线程回收函数（对应进程中 waitpid() 函数）"></a>4.1线程回收函数（对应进程中 waitpid() 函数）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个阻塞函数, 由主线程调用，然后就阻塞在这，直到thread子线程退出，然后返回。</span></span><br><span class="line"><span class="comment">// 回收对应的子线程资源</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>thread：要被回收的子线程的线程 ID</li><li>retval：被回收的子线程通过它传出 <code>pthread_exit</code>的参数，即要传出的数据。</li></ul></li></ul><h3 id="4-2实例"><a href="#4-2实例" class="headerlink" title="4.2实例"></a>4.2实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mytask</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test</span> * <span class="title">pt</span> =</span> (struct Test *)arg;</span><br><span class="line">    pt-&gt;num = <span class="number">1000</span>;</span><br><span class="line">    pt-&gt;age = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子线程：i = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_exit(pt); <span class="comment">// 直接退出子线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程TID：%ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">test</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子线程用到了主线程的栈空间test，所以主线程必须等子线程退出后再退出</span></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, mytask, &amp;test);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程TID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主线程TID：%ld\n&quot;</span>, pthread_self());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 子线程回收资源被存放在此</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test</span>* <span class="title">tmp</span> =</span> (struct Test*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程返回数据: age: %d, num: %d\n&quot;</span>, tmp-&gt;age, tmp-&gt;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# gcc my_pthread_create.c -lpthread -o app</span><br><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ./app </span><br><span class="line">子线程创建成功, 线程TID: 140123287721728</span><br><span class="line">主线程TID：140123287725888</span><br><span class="line">子线程：i = 0</span><br><span class="line">子线程：i = 1</span><br><span class="line">子线程：i = 2</span><br><span class="line">子线程：i = 3</span><br><span class="line">子线程：i = 4</span><br><span class="line">子线程：i = 5</span><br><span class="line">子线程：i = 6</span><br><span class="line">子线程：i = 7</span><br><span class="line">子线程返回数据: age: 99, num: 1000</span><br><span class="line">子线程资源被成功回收...</span><br><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# </span><br></pre></td></tr></table></figure><p>注意：虽然每个线程都有属于自己的栈区空间，但是位于同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的。当然，线程创建函数<code>pthread_create</code>的参数<code>arg</code>也可以是全局变量或者堆存的内存。</p><h2 id="5、Linux线程分离"><a href="#5、Linux线程分离" class="headerlink" title="5、Linux线程分离"></a>5、Linux线程分离</h2><p>有时候，进程中的主线程也有自己的业务处理流程，如果还是让主线程负责子线程的资源回收，调用 <code>pthread_join</code>后，只要子线程不退出主线程就会一直被阻塞，主线程就没办法执行自己的业务处理流程了。</p><p>这就是线程分离函数<code>pthread_detach</code>的应用场景了，调用线程分离函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源会被系统的其他进程接管并回收了。线程分离之后在主线程中使用 <code>pthread_join</code>是回收不到子线程资源了的。</p><h3 id="5-1线程分离函数"><a href="#5-1线程分离函数" class="headerlink" title="5.1线程分离函数"></a>5.1线程分离函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数：</p><ul><li>thread：要与主线程分离的子线程的线程ID。</li></ul></li><li><p>返回值：成功返回0，失败返回错误码。</p></li></ul><h3 id="5-2实例"><a href="#5-2实例" class="headerlink" title="5.2实例"></a>5.2实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mytask</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子线程：i = %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程TID：%ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, mytask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程TID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主线程TID：%ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程子线程分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主线程你自己先退出吧，不用管我，我一个“人”很好</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序编译运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# gcc my_pthread_create.c -lpthread -o app</span><br><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ./app </span><br><span class="line">子线程创建成功, 线程TID: 139791846512384</span><br><span class="line">主线程TID：139791846516544</span><br><span class="line">子线程：i = 0</span><br><span class="line">子线程：i = 1</span><br><span class="line">子线程：i = 2</span><br><span class="line">子线程：i = 3</span><br><span class="line">子线程：i = 4</span><br><span class="line">子线程：i = 5</span><br><span class="line">子线程：i = 6</span><br><span class="line">子线程：i = 7</span><br><span class="line">子线程：i = 8</span><br><span class="line">子线程：i = 9</span><br><span class="line">子线程TID：139791846512384</span><br><span class="line">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# </span><br></pre></td></tr></table></figure><h2 id="6、Linux其它线程函数"><a href="#6、Linux其它线程函数" class="headerlink" title="6、Linux其它线程函数"></a>6、Linux其它线程函数</h2><h3 id="6-1线程取消函数（对应进程中-kill-函数）"><a href="#6-1线程取消函数（对应进程中-kill-函数）" class="headerlink" title="6.1线程取消函数（对应进程中 kill() 函数）"></a>6.1线程取消函数（对应进程中 kill() 函数）</h3><p>杀死（取消）线程 其作用。但不会立刻杀死（取消）进程，只有当<code>thread</code>进行了一次系统调用（从用户区切换到内核区），才会死掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数：</p><ul><li>thread：要杀死（取消）线程的线程ID。</li></ul></li><li><p>返回值：成功返回0，失败返回错误码。</p></li></ul><h3 id="6-2线程ID是否相同函数"><a href="#6-2线程ID是否相同函数" class="headerlink" title="6.2线程ID是否相同函数"></a>6.2线程ID是否相同函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数：两个要比较的线程ID。</p></li><li><p>返回值：两个线程 ID 相等返回非 0 值，如果不相等返回 0。</p></li></ul><h2 id="7、埋个坑"><a href="#7、埋个坑" class="headerlink" title="7、埋个坑"></a>7、埋个坑</h2><ol><li>多线程的同步与互斥使用</li><li>线程池</li><li>高并发</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux下线程的使用&quot;&gt;&lt;a href=&quot;#Linux下线程的使用&quot; class=&quot;headerlink&quot; title=&quot;Linux下线程的使用&quot;&gt;&lt;/a&gt;Linux下线程的使用&lt;/h1&gt;&lt;h2 id=&quot;1、Linux线程&quot;&gt;&lt;a href=&quot;#1、Linux线</summary>
      
    
    
    
    <category term="Linux" scheme="http://alanchans.github.io/categories/Linux/"/>
    
    <category term="线程进程" scheme="http://alanchans.github.io/categories/Linux/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="http://alanchans.github.io/tags/Linux/"/>
    
    <category term="线程进程" scheme="http://alanchans.github.io/tags/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程、线程</title>
    <link href="http://alanchans.github.io/2021/06/25/threadDescription/"/>
    <id>http://alanchans.github.io/2021/06/25/threadDescription/</id>
    <published>2021-06-24T18:35:39.000Z</published>
    <updated>2021-06-24T18:49:53.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><hr><h3 id="1、什么是进程、线程"><a href="#1、什么是进程、线程" class="headerlink" title="1、什么是进程、线程"></a>1、什么是进程、线程</h3><p>进程是一个程序被加载到内存执行的过程，它是一个动态的概念。线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元。进程是操作系统分配资源的最小单位，线程是操作系统调度执行的最小单位。打个比喻，操作系统是好像一个大工厂，工厂里面的一条条流水线就是一个个的进程，然后流水线上的工人负责整个流水作业的全部或者一小部分，这就叫线程。进程是真正的“打工人”，干活的实体。</p><hr><h3 id="2、进程和线程的区别"><a href="#2、进程和线程的区别" class="headerlink" title="2、进程和线程的区别"></a>2、进程和线程的区别</h3><ul><li>进程有自己独立的地址空间（每个进程都有拥有4GBytes的虚拟地址空间），多个线程共用同一个地址空间。</li><li>同一进程内的每个线程共享代码段(.text)，堆区(heap)，全局数据区(.data.bss)，文件描述符表。</li><li>同一进程内的每个线程独享自己的栈、寄存器。</li></ul><hr><h3 id="3、进程线程的特点"><a href="#3、进程线程的特点" class="headerlink" title="3、进程线程的特点"></a>3、进程线程的特点</h3><ul><li><p>进程</p><ul><li>进程拥有自己的地址空间，各进程间相互独立，一个进程挂死，不会影响到其他进程。</li></ul></li><li><p>线程</p><ul><li><p>线程占更小的系统资源，线程的上下文切换比进程要快的多。</p><blockquote><p>上下文切换：进程 / 线程分时复用 CPU 时间片，在切换之前会将上一个任务的状态进行保存，下次切换回这个任务的时候，加载这个状态继续运行，任务从保存到再次加载这个过程就是一次上下文切换。</p></blockquote></li><li><p>线程启动速度快，退出也快，对系统资源的冲击小。</p></li><li><p>一个进程内的某一个线程挂掉，那么整个进程就会挂掉。</p></li></ul></li></ul><hr><h3 id="4、进程间的通讯方式"><a href="#4、进程间的通讯方式" class="headerlink" title="4、进程间的通讯方式"></a>4、进程间的通讯方式</h3><ol><li>管道pipe。半双工，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，常见于父子进程。</li><li>有名管道FIFO。半双工，数据只能单向流动，允许无亲缘关系进程间的通信。</li><li>消息队列MessageQueue。消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问，防止多进程访问共享资源时产生竞争。是进程同步的一种手段。</li><li>套接字Socket：用于不同机器间的进程通信，网络通信少不了它。</li><li>信号 Signal： 段错误、kill -9 的时候就是这种信号。</li></ol><hr><h3 id="5、线程间通信方式"><a href="#5、线程间通信方式" class="headerlink" title="5、线程间通信方式"></a>5、线程间通信方式</h3><blockquote><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p></blockquote><ol><li>锁机制：包括互斥锁、条件变量、读写锁。<ul><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法，常用于多线程间对共享资源的访问保护。</li><li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li>信号量机制(Semaphore)：信号量既是是进程同步的一种手段，也是线程同步的一种手段。</li><li>信号机制(Signal)：类似进程间的信号处理。线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程、线程&quot;&gt;&lt;a href=&quot;#进程、线程&quot; class=&quot;headerlink&quot; title=&quot;进程、线程&quot;&gt;&lt;/a&gt;进程、线程&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;1、什么是进程、线程&quot;&gt;&lt;a href=&quot;#1、什么是进程、线程&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="线程进程" scheme="http://alanchans.github.io/categories/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/"/>
    
    
    <category term="线程进程" scheme="http://alanchans.github.io/tags/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="http://alanchans.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="进程" scheme="http://alanchans.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://alanchans.github.io/2021/06/23/hello-world/"/>
    <id>http://alanchans.github.io/2021/06/23/hello-world/</id>
    <published>2021-06-22T17:50:48.426Z</published>
    <updated>2021-06-22T17:50:48.426Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
