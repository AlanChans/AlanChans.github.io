<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post."></a>Create a new post.</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux下线程的使用</title>
    <url>/2021/06/25/linuxPthread/</url>
    <content><![CDATA[<h1 id="Linux下线程的使用"><a href="#Linux下线程的使用" class="headerlink" title="Linux下线程的使用"></a>Linux下线程的使用</h1><h2 id="1、Linux线程"><a href="#1、Linux线程" class="headerlink" title="1、Linux线程"></a>1、Linux线程</h2><ul>
<li><p>在早期的类Unix系统中是没有“线程”概念的，这是后面需求的才延伸出来的，它借助了进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。在Linux环境下的线程本质上还是进程，属于轻量级的进程（LWP：light weight process）。</p>
</li>
<li><p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。</p>
</li>
<li>fork复制对方的地址空间，产生一个“进程”；pthread_create共享对方的地址空间，就产生一个“线程”。</li>
</ul>
<h2 id="2、Linux线程创建"><a href="#2、Linux线程创建" class="headerlink" title="2、Linux线程创建"></a>2、Linux线程创建</h2><blockquote>
<p>使用下面所有的线程相关函数都必须做的工作：</p>
<p>1、包含头文件  #include <pthread.h></p>
<p>2、编译时链接线程库(线程库的名字叫pthread, 全名: libpthread.so libptread.a) -pthread</p>
</blockquote>
<h3 id="2-1获取线程ID（对应进程中-getpid-函数）"><a href="#2-1获取线程ID（对应进程中-getpid-函数）" class="headerlink" title="2.1获取线程ID（对应进程中 getpid() 函数）"></a>2.1获取线程ID（对应进程中 getpid() 函数）</h3><p>每一个线程都对应一个唯一的线程 ID（两个进程间，线程ID允许相同），ID 类型为 pthread_t，这个 ID 是一个无符号长整形数(%lu)，如果想要获取当前线程的线程 ID，可以调用如下函数：</p>
<pre class=" language-lang-c"><code class="language-lang-c">pthread_t pthread_self(void);    // 返回当前线程的线程ID，man说这个函数总会执行成功
</code></pre>
<h3 id="2-2创建线程函数（对应进程中fork-函数）"><a href="#2-2创建线程函数（对应进程中fork-函数）" class="headerlink" title="2.2创建线程函数（对应进程中fork() 函数）"></a>2.2创建线程函数（对应进程中fork() 函数）</h3><pre class=" language-lang-c"><code class="language-lang-c">int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
</code></pre>
<ul>
<li><p>参数：</p>
<ul>
<li>thread：传出参数，创建成功时保存系统为我们分配好的线程ID。</li>
<li>attr：通常传NULL，表示使用线程默认属性。也可自行修改。</li>
<li>start_routine：函数指针，指向线程任务函数(线程体)，该函数运行结束，则线程结束。该函数在子线程中执行。</li>
<li>arg：通过它把需要传递的参数传递到start_routine指向的函数体内部，如要传多个参数, 可以用结构封装。</li>
</ul>
</li>
<li><p>返回值：成功返回0； 失败返回错误号。具体错误可通过strerror()函数输出。</p>
</li>
</ul>
<h3 id="2-3实例"><a href="#2-3实例" class="headerlink" title="2.3实例"></a>2.3实例</h3><pre class=" language-lang-c"><code class="language-lang-c">// my_pthread_create.c 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

struct Test
&#123;
    int num;
    int age;
&#125;;
void * mytask(void * arg)
&#123;
    for (int i = 0; i < 5; i++)
    &#123;
        printf("子线程：i = %d\n", i);
    &#125;
    printf("子线程TID：%ld\n", pthread_self());

    struct Test * pt = (struct Test *)arg;
    pt->num = 1000;
    pt->age = 99;

    return NULL;
&#125;
int main()
&#123;
    pthread_t tid;
    struct Test test;

    pthread_create(&tid, NULL, mytask, &test);
    printf("子线程创建成功, 线程TID: %ld\n", tid);
    printf("主线程TID：%ld\n", pthread_self());

    return 0;
&#125;
</code></pre>
<p>执行命令编译程序，<code>-lpthread</code>的意思是链接<code>pthread</code>线程库，要用线程相关函数除了包含头文件<code>#include &lt;pthread.h&gt;</code>以外，编译的时候还得指定链接线程库，否则编译失败。<code>-o app</code>的意思是指定输出的可执行文件名为<code>app</code>。</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">gcc my_pthread_create.c -lpthread -o app
</code></pre>
<pre class=" language-lang-shell"><code class="language-lang-shell">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# gcc my_pthread_create.c -lpthread -o app
root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ls
app  my_pthread_create.c
root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ./app 
子线程创建成功, 线程TID: 139769949230848
主线程TID：139769949235008
root@iZwz94euuu9omhoocm3l5uZ:~/07_article#
</code></pre>
<p>编译执行后发现子线程虽然创建成功，但是子线程任务函数里面的打印并没有输出，原因是：</p>
<p>主线程一直在运行，执行期间创建出了子线程，接下来主线程和子线程“并发”，分道扬镳，各自执行自己的函数。子线程刚被创建出来，需要去抢CPU时间片，抢到了CPU时间片子线程的任务函数才能运行。</p>
<p>很明显，此时此刻，子线程并没有抢到CPU时间片，而主线程却抢到了。然后主线程去执行printf，执行完后发现没有工作要做了就直接返回退出了。</p>
<p>但主线程退出了, 虚拟地址空间就被释放了, 子线程就一并被销毁了，这样子线程任务函数里的printf就肯定没法运行了。</p>
<h2 id="3、Linux线程退出"><a href="#3、Linux线程退出" class="headerlink" title="3、Linux线程退出"></a>3、Linux线程退出</h2><p>在多线程进程中，要让主线程退出不导致虚拟地址空间的释放，剩下的子线程继续正常运行，可以在主线程中调用线程退出函数。线程退出函数会让当前线程马上退出，而且不会释放虚拟地址空间，不会影响到其他线程的正常运行。线程退出函数可以在子线程或者主线程中都使用。</p>
<h3 id="3-1线程退出函数"><a href="#3-1线程退出函数" class="headerlink" title="3.1线程退出函数"></a>3.1线程退出函数</h3><pre class=" language-lang-c"><code class="language-lang-c">void pthread_exit(void *retval);
</code></pre>
<ul>
<li>参数：线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为 NULL。一般使用的这个线程退出带出数据的功能的时候，需要在线程创建的时候把一块堆内存的指针传进去。</li>
</ul>
<h3 id="3-2实例"><a href="#3-2实例" class="headerlink" title="3.2实例"></a>3.2实例</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

struct Test
&#123;
    int num;
    int age;
&#125;;
void * mytask(void * arg)
&#123;
    for (int i = 0; i < 10; i++)
    &#123;
        printf("子线程：i = %d\n", i);
        if(i == 7)
        &#123;
            pthread_exit(NULL); // 直接退出子线程
        &#125;
    &#125;
    printf("子线程TID：%ld\n", pthread_self());

    struct Test * pt = (struct Test *)arg;
    pt->num = 1000;
    pt->age = 99;

    return NULL;
&#125;
int main()
&#123;
    pthread_t tid;
    struct Test test;

    pthread_create(&tid, NULL, mytask, &test);
    printf("子线程创建成功, 线程TID: %ld\n", tid);
    printf("主线程TID：%ld\n", pthread_self());

    pthread_exit(NULL); // 主线程退出，不会释放虚拟地址空间，不影响子线程运行
    return 0;
&#125;
</code></pre>
<p>编译执行结果：</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# gcc my_pthread_create.c -lpthread -o app
root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ./app 
子线程创建成功, 线程TID: 139901666547456
主线程TID：139901666551616
子线程：i = 0
子线程：i = 1
子线程：i = 2
子线程：i = 3
子线程：i = 4
子线程：i = 5
子线程：i = 6
子线程：i = 7
root@iZwz94euuu9omhoocm3l5uZ:~/07_article#
</code></pre>
<p>上面的程序执行结果说明，主线程执行<code>printf</code>就先退出了，此时虚拟地址空间还没有被释放，子线程继续执行<code>printf</code>，直到子线程执行到<code>pthread_exit</code>子线程就退出了，然后虚拟地址空间被释放，进程退出。</p>
<h2 id="4、Linux线程回收"><a href="#4、Linux线程回收" class="headerlink" title="4、Linux线程回收"></a>4、Linux线程回收</h2><p>子线程在一般情况下都是由主线程创建并启动的，如果子线程相对主线程而言要进行大量的耗时的运算，那么主线程就会先于子线程结束，就好比如<code>3.2实例</code>。但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束线程和进程，这种情况该怎么处理呢？</p>
<p>这就是线程回收函数 <code>pthread_join</code>的应用场景了，这个函数是一个阻塞函数，如果子线程还在运行，该函数就会一直阻塞，子线程退出函数解除阻塞进行资源的回收。函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p>
<h3 id="4-1线程回收函数（对应进程中-waitpid-函数）"><a href="#4-1线程回收函数（对应进程中-waitpid-函数）" class="headerlink" title="4.1线程回收函数（对应进程中 waitpid() 函数）"></a>4.1线程回收函数（对应进程中 waitpid() 函数）</h3><pre class=" language-lang-c"><code class="language-lang-c">// 这是一个阻塞函数, 由主线程调用，然后就阻塞在这，直到thread子线程退出，然后返回。
// 回收对应的子线程资源
int pthread_join(pthread_t thread, void **retval);
</code></pre>
<ul>
<li>参数：<ul>
<li>thread：要被回收的子线程的线程 ID</li>
<li>retval：被回收的子线程通过它传出 <code>pthread_exit</code>的参数，即要传出的数据。</li>
</ul>
</li>
</ul>
<h3 id="4-2实例"><a href="#4-2实例" class="headerlink" title="4.2实例"></a>4.2实例</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

struct Test
&#123;
    int num;
    int age;
&#125;;
void * mytask(void * arg)
&#123;
    struct Test * pt = (struct Test *)arg;
    pt->num = 1000;
    pt->age = 99;
    for (int i = 0; i < 10; i++)
    &#123;
        printf("子线程：i = %d\n", i);
        if(i == 7)
        &#123;
            pthread_exit(pt); // 直接退出子线程
        &#125;
    &#125;
    printf("子线程TID：%ld\n", pthread_self());

    return NULL;
&#125;
int main()
&#123;
    pthread_t tid;
    struct Test test;

    // 子线程用到了主线程的栈空间test，所以主线程必须等子线程退出后再退出
    pthread_create(&tid, NULL, mytask, &test);
    printf("子线程创建成功, 线程TID: %ld\n", tid);
    printf("主线程TID：%ld\n", pthread_self());

    void* ptr = NULL;
    // ptr是一个传出参数, 子线程回收资源被存放在此
    // 这个内存地址就是pthread_exit() 参数指向的内存
    // 阻塞等待子线程退出
    pthread_join(tid, &ptr);

    struct Test* tmp = (struct Test*)ptr;
    printf("子线程返回数据: age: %d, num: %d\n", tmp->age, tmp->num);
    printf("子线程资源被成功回收...\n");

    return 0;
&#125;
</code></pre>
<p>编译执行结果：</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# gcc my_pthread_create.c -lpthread -o app
root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ./app 
子线程创建成功, 线程TID: 140123287721728
主线程TID：140123287725888
子线程：i = 0
子线程：i = 1
子线程：i = 2
子线程：i = 3
子线程：i = 4
子线程：i = 5
子线程：i = 6
子线程：i = 7
子线程返回数据: age: 99, num: 1000
子线程资源被成功回收...
root@iZwz94euuu9omhoocm3l5uZ:~/07_article#
</code></pre>
<p>注意：虽然每个线程都有属于自己的栈区空间，但是位于同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的。当然，线程创建函数<code>pthread_create</code>的参数<code>arg</code>也可以是全局变量或者堆存的内存。</p>
<h2 id="5、Linux线程分离"><a href="#5、Linux线程分离" class="headerlink" title="5、Linux线程分离"></a>5、Linux线程分离</h2><p>有时候，进程中的主线程也有自己的业务处理流程，如果还是让主线程负责子线程的资源回收，调用 <code>pthread_join</code>后，只要子线程不退出主线程就会一直被阻塞，主线程就没办法执行自己的业务处理流程了。</p>
<p>这就是线程分离函数<code>pthread_detach</code>的应用场景了，调用线程分离函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源会被系统的其他进程接管并回收了。线程分离之后在主线程中使用 <code>pthread_join</code>是回收不到子线程资源了的。</p>
<h3 id="5-1线程分离函数"><a href="#5-1线程分离函数" class="headerlink" title="5.1线程分离函数"></a>5.1线程分离函数</h3><pre class=" language-lang-c"><code class="language-lang-c">int pthread_detach(pthread_t thread);
</code></pre>
<ul>
<li><p>参数：</p>
<ul>
<li>thread：要与主线程分离的子线程的线程ID。</li>
</ul>
</li>
<li><p>返回值：成功返回0，失败返回错误码。</p>
</li>
</ul>
<h3 id="5-2实例"><a href="#5-2实例" class="headerlink" title="5.2实例"></a>5.2实例</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

void * mytask(void * arg)
&#123;

    for (int i = 0; i < 10; i++)
    &#123;
        printf("子线程：i = %d\n", i);

    &#125;
    printf("子线程TID：%ld\n", pthread_self());

    return NULL;
&#125;
int main()
&#123;
    pthread_t tid;

    pthread_create(&tid, NULL, mytask, NULL);
    printf("子线程创建成功, 线程TID: %ld\n", tid);
    printf("主线程TID：%ld\n", pthread_self());

    // 主线程子线程分离
    pthread_detach(tid);

    // 主线程你自己先退出吧，不用管我，我一个“人”很好
    pthread_exit(NULL);

    return 0;
&#125;
</code></pre>
<p>程序编译运行结果：</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# gcc my_pthread_create.c -lpthread -o app
root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ./app 
子线程创建成功, 线程TID: 139791846512384
主线程TID：139791846516544
子线程：i = 0
子线程：i = 1
子线程：i = 2
子线程：i = 3
子线程：i = 4
子线程：i = 5
子线程：i = 6
子线程：i = 7
子线程：i = 8
子线程：i = 9
子线程TID：139791846512384
root@iZwz94euuu9omhoocm3l5uZ:~/07_article#
</code></pre>
<h2 id="6、Linux其它线程函数"><a href="#6、Linux其它线程函数" class="headerlink" title="6、Linux其它线程函数"></a>6、Linux其它线程函数</h2><h3 id="6-1线程取消函数（对应进程中-kill-函数）"><a href="#6-1线程取消函数（对应进程中-kill-函数）" class="headerlink" title="6.1线程取消函数（对应进程中 kill() 函数）"></a>6.1线程取消函数（对应进程中 kill() 函数）</h3><p>杀死（取消）线程 其作用。但不会立刻杀死（取消）进程，只有当<code>thread</code>进行了一次系统调用（从用户区切换到内核区），才会死掉。</p>
<pre class=" language-lang-c"><code class="language-lang-c">int pthread_cancel(pthread_t thread);
</code></pre>
<ul>
<li><p>参数：</p>
<ul>
<li>thread：要杀死（取消）线程的线程ID。</li>
</ul>
</li>
<li><p>返回值：成功返回0，失败返回错误码。</p>
</li>
</ul>
<h3 id="6-2线程ID是否相同函数"><a href="#6-2线程ID是否相同函数" class="headerlink" title="6.2线程ID是否相同函数"></a>6.2线程ID是否相同函数</h3><pre class=" language-lang-c"><code class="language-lang-c">int pthread_equal(pthread_t t1, pthread_t t2);
</code></pre>
<ul>
<li><p>参数：两个要比较的线程ID。</p>
</li>
<li><p>返回值：两个线程 ID 相等返回非 0 值，如果不相等返回 0。</p>
</li>
</ul>
<h2 id="7、埋个坑"><a href="#7、埋个坑" class="headerlink" title="7、埋个坑"></a>7、埋个坑</h2><ol>
<li>多线程的同步与互斥使用</li>
<li>线程池</li>
<li>高并发</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>线程进程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>线程进程</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL数据库的基本操作</title>
    <url>/2021/07/03/mysql/</url>
    <content><![CDATA[<h1 id="MYSQL数据库的基本操作"><a href="#MYSQL数据库的基本操作" class="headerlink" title="MYSQL数据库的基本操作"></a>MYSQL数据库的基本操作</h1><h2 id="1、root登录mysql"><a href="#1、root登录mysql" class="headerlink" title="1、root登录mysql"></a>1、root登录mysql</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql -uroot -p
Enter password: *****
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 8
Server version: 8.0.25 MySQL Community Server - GPL

Copyright (c) 2000, 2021, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
</code></pre>
<h2 id="2、查看数据库"><a href="#2、查看数据库" class="headerlink" title="2、查看数据库"></a>2、查看数据库</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
</code></pre>
<h2 id="3、查看表"><a href="#3、查看表" class="headerlink" title="3、查看表"></a>3、查看表</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> use mysql
Database changed
mysql> show tables;
+------------------------------------------------------+
| Tables_in_mysql                                      |
+------------------------------------------------------+
| columns_priv                                         |
| component                                            |
| db                                                   |
| default_roles                                        |
| engine_cost                                          |
| func                                                 |
| general_log                                          |
| global_grants                                        |
| gtid_executed                                        |
| help_category                                        |
| help_keyword                                         |
| help_relation                                        |
| help_topic                                           |
| innodb_index_stats                                   |
| innodb_table_stats                                   |
| password_history                                     |
| plugin                                               |
| procs_priv                                           |
| proxies_priv                                         |
| replication_asynchronous_connection_failover         |
| replication_asynchronous_connection_failover_managed |
| role_edges                                           |
| server_cost                                          |
| servers                                              |
| slave_master_info                                    |
| slave_relay_log_info                                 |
| slave_worker_info                                    |
| slow_log                                             |
| tables_priv                                          |
| time_zone                                            |
| time_zone_leap_second                                |
| time_zone_name                                       |
| time_zone_transition                                 |
| time_zone_transition_type                            |
| user                                                 |
+------------------------------------------------------+
</code></pre>
<h2 id="4、退出数据库"><a href="#4、退出数据库" class="headerlink" title="4、退出数据库"></a>4、退出数据库</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> exit;
Bye
</code></pre>
<h2 id="5、创建数据库"><a href="#5、创建数据库" class="headerlink" title="5、创建数据库"></a>5、创建数据库</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> create database mydb01;
</code></pre>
<h2 id="6、创建表"><a href="#6、创建表" class="headerlink" title="6、创建表"></a>6、创建表</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> create table employee(id int, name varchar(30), sex int, birthday date, salary double, entry_date date, resume text);
</code></pre>
<h2 id="7、创建表数据"><a href="#7、创建表数据" class="headerlink" title="7、创建表数据"></a>7、创建表数据</h2><pre class=" language-lang-sql"><code class="language-lang-sql">insert into employee values(1,'韩信',1,'1997-07-07',15000,'2020-02-02','突进刺客');
insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(2,'兰陵王',1,'1996-06-06',12000,'2020-01-01','脆皮刺客');
insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(3,'亚瑟',1,'1000-01-01',8000,'2020-10-01','前排坦克');
</code></pre>
<h2 id="查看表信息"><a href="#查看表信息" class="headerlink" title="查看表信息"></a>查看表信息</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> desc employee;
+------------+-------------+------+-----+---------+-------+
| Field      | Type        | Null | Key | Default | Extra |
+------------+-------------+------+-----+---------+-------+
| id         | int         | YES  |     | NULL    |       |
| name       | varchar(30) | YES  |     | NULL    |       |
| sex        | int         | YES  |     | NULL    |       |
| birthday   | date        | YES  |     | NULL    |       |
| salary     | double      | YES  |     | NULL    |       |
| entry_date | date        | YES  |     | NULL    |       |
| resume     | text        | YES  |     | NULL    |       |
+------------+-------------+------+-----+---------+-------+
</code></pre>
<h2 id="8、查看表数据"><a href="#8、查看表数据" class="headerlink" title="8、查看表数据"></a>8、查看表数据</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> select * from employee;
+------+--------+------+------------+--------+------------+----------+
| id   | name   | sex  | birthday   | salary | entry_date | resume   |
+------+--------+------+------------+--------+------------+----------+
|    1 | 韩信   |    1 | 1997-07-07 |  15000 | 2020-02-02 | 突进刺客 |
|    2 | 兰陵王 |    1 | 1996-06-06 |  12000 | 2020-01-01 | 脆皮刺客 |
|    3 | 亚瑟   |    1 | 1000-01-01 |   8000 | 2020-10-01 | 前排坦克 |
+------+--------+------+------------+--------+------------+----------+
</code></pre>
<h2 id="修改某个项的内容"><a href="#修改某个项的内容" class="headerlink" title="修改某个项的内容"></a>修改某个项的内容</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> update employee set resume='偷家小贼' where id=1;
Query OK, 1 row affected (0.01 sec)

mysql> select * from employee;
+------+--------+------+------------+--------+------------+----------+
| id   | name   | sex  | birthday   | salary | entry_date | resume   |
+------+--------+------+------------+--------+------------+----------+
|    1 | 韩信   |    1 | 1997-07-07 |  15000 | 2020-02-02 | 偷家小贼 |
|    2 | 兰陵王 |    1 | 1996-06-06 |  12000 | 2020-01-01 | 脆皮刺客 |
|    3 | 亚瑟   |    1 | 1000-01-01 |   8000 | 2020-10-01 | 前排坦克 |
+------+--------+------+------------+--------+------------+----------+
</code></pre>
<h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><pre class=" language-lang-sql"><code class="language-lang-sql">create table students(id int, name varchar(20), chinese int, english int, math int);
insert into students(id, name, chinese, english, math) values(1, '黄真', 80, 85, 90);
insert into students(id, name, chinese, english, math) values(2, '归辛树', 90, 95, 95);
insert into students(id, name, chinese, english, math) values(3, '李寻欢', 80, 96, 96);
insert into students(id, name, chinese, english, math) values(4, '叶开', 81, 97, 85);
insert into students(id, name, chinese, english, math) values(5, '袁承志', 85, 84, 90);
insert into students(id, name, chinese, english, math) values(6, '何红药', 92, 85, 87);
insert into students(id, name, chinese, english, math) values(7, '何铁手', 75, 81, 80);
insert into students(id, name, chinese, english, math) values(8, '夏雪宜', 77, 80, 79);
insert into students(id, name, chinese, english, math) values(9, '任我行', 95, 85, 85);
insert into students(id, name, chinese, english, math) values(10, '岳不群', 94, 85, 84);


增加一列：
alter table students add class_id int;

id <= 5 为1班， id > 5 为2班
update students set class_id=1 where id <= 5;

select ceil(id/5),id from students;

update students set class_id=ceil(id/5);

求平均
select avg(english),class_id from students group by class_id;

求和
select sum(chinese+math+english), class_id from students group by class_id;
+---------------------------+----------+
| sum(chinese+math+english) | class_id |
+---------------------------+----------+
|                      1329 |        1 |
|                      1264 |        2 |
+---------------------------+----------+

找到总分大于1300的
select sum(chinese+english+math), class_id from students group by class_id having sum(chinese+english+math)>1300;
+---------------------------+----------+
| sum(chinese+english+math) | class_id |
+---------------------------+----------+
|                      1329 |        1 |
+---------------------------+----------+

查看当前时间
select now() from dual;
+---------------------+
| now()               |
+---------------------+
| 2021-06-19 14:44:07 |
+---------------------+


select now()-1,now(),now()+1 from dual;
+----------------+---------------------+----------------+
| now()-1        | now()               | now()+1        |
+----------------+---------------------+----------------+
| 20210619164648 | 2021-06-19 16:46:49 | 20210619164650 |
+----------------+---------------------+----------------+


求今天、昨天、明天
select date_add(now(), interval -1 day), now(), date_add(now(), interval 1 day) from dual;
+----------------------------------+---------------------+---------------------------------+
| date_add(now(), interval -1 day) | now()               | date_add(now(), interval 1 day) |
+----------------------------------+---------------------+---------------------------------+
| 2021-06-18 16:53:37              | 2021-06-19 16:53:37 | 2021-06-20 16:53:37             |
+----------------------------------+---------------------+---------------------------------+
1 row in set (0.07 sec)

select addtime(now(),'0:1:0'),now() from dual;
+------------------------+---------------------+
| addtime(now(),'0:1:0') | now()               |
+------------------------+---------------------+
| 2021-06-19 17:00:34    | 2021-06-19 16:59:34 |
+------------------------+---------------------+

字符串
select concat('hello ', 'mysql', 'yyds', '123.') from dual;
+-------------------------------------------+
| concat('hello ', 'mysql', 'yyds', '123.') |
+-------------------------------------------+
| hello mysqlyyds123.                       |
+-------------------------------------------+
1 row in set (0.00 sec)
</code></pre>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程</title>
    <url>/2021/06/25/threadDescription/</url>
    <content><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><hr>
<h3 id="1、什么是进程、线程"><a href="#1、什么是进程、线程" class="headerlink" title="1、什么是进程、线程"></a>1、什么是进程、线程</h3><p>进程是一个程序被加载到内存执行的过程，它是一个动态的概念。线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元。进程是操作系统分配资源的最小单位，线程是操作系统调度执行的最小单位。打个比喻，操作系统是好像一个大工厂，工厂里面的一条条流水线就是一个个的进程，然后流水线上的工人负责整个流水作业的全部或者一小部分，这就叫线程。进程是真正的“打工人”，干活的实体。</p>
<hr>
<h3 id="2、进程和线程的区别"><a href="#2、进程和线程的区别" class="headerlink" title="2、进程和线程的区别"></a>2、进程和线程的区别</h3><ul>
<li>进程有自己独立的地址空间（每个进程都有拥有4GBytes的虚拟地址空间），多个线程共用同一个地址空间。</li>
<li>同一进程内的每个线程共享代码段(.text)，堆区(heap)，全局数据区(.data.bss)，文件描述符表。</li>
<li>同一进程内的每个线程独享自己的栈、寄存器。</li>
</ul>
<hr>
<h3 id="3、进程线程的特点"><a href="#3、进程线程的特点" class="headerlink" title="3、进程线程的特点"></a>3、进程线程的特点</h3><ul>
<li><p>进程</p>
<ul>
<li>进程拥有自己的地址空间，各进程间相互独立，一个进程挂死，不会影响到其他进程。</li>
</ul>
</li>
<li><p>线程</p>
<ul>
<li><p>线程占更小的系统资源，线程的上下文切换比进程要快的多。</p>
<blockquote>
<p>上下文切换：进程 / 线程分时复用 CPU 时间片，在切换之前会将上一个任务的状态进行保存，下次切换回这个任务的时候，加载这个状态继续运行，任务从保存到再次加载这个过程就是一次上下文切换。</p>
</blockquote>
</li>
<li><p>线程启动速度快，退出也快，对系统资源的冲击小。</p>
</li>
<li><p>一个进程内的某一个线程挂掉，那么整个进程就会挂掉。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4、进程间的通讯方式"><a href="#4、进程间的通讯方式" class="headerlink" title="4、进程间的通讯方式"></a>4、进程间的通讯方式</h3><ol>
<li>管道pipe。半双工，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，常见于父子进程。</li>
<li>有名管道FIFO。半双工，数据只能单向流动，允许无亲缘关系进程间的通信。</li>
<li>消息队列MessageQueue。消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问，防止多进程访问共享资源时产生竞争。是进程同步的一种手段。</li>
<li>套接字Socket：用于不同机器间的进程通信，网络通信少不了它。</li>
<li>信号 Signal： 段错误、kill -9 的时候就是这种信号。</li>
</ol>
<hr>
<h3 id="5、线程间通信方式"><a href="#5、线程间通信方式" class="headerlink" title="5、线程间通信方式"></a>5、线程间通信方式</h3><blockquote>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
</blockquote>
<ol>
<li>锁机制：包括互斥锁、条件变量、读写锁。<ul>
<li>互斥锁提供了以排他方式防止数据结构被并发修改的方法，常用于多线程间对共享资源的访问保护。</li>
<li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
</li>
<li>信号量机制(Semaphore)：信号量既是是进程同步的一种手段，也是线程同步的一种手段。</li>
<li>信号机制(Signal)：类似进程间的信号处理。线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</li>
</ol>
]]></content>
      <categories>
        <category>线程进程</category>
      </categories>
      <tags>
        <tag>线程进程</tag>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信IPC</title>
    <url>/2021/06/29/ipc/</url>
    <content><![CDATA[<h1 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h1><p>IPC（Inter-Process Communication，进程间通信）。进程间通信是指两个进程的数据之间产生交互。</p>
<h2 id="1、管道"><a href="#1、管道" class="headerlink" title="1、管道"></a>1、管道</h2><h3 id="1-1基本概念"><a href="#1-1基本概念" class="headerlink" title="1.1基本概念"></a>1.1基本概念</h3><p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。</p>
<ul>
<li>本质是一个伪文件（实为内核缓冲区）。</li>
<li>有两个文件描述符，一个表示读端(<code>fd[1]</code>)，一个表示写端(<code>fd[0]</code>)。</li>
<li>规定数据从管道的写端流入，从读端流出。</li>
<li>双向半双工。</li>
</ul>
<p>原理：管道实为内核使用环形队列机制，借助内核缓冲区（4k）实现。</p>
<p>缺点：</p>
<ul>
<li>数据只能自己读不能自己写。</li>
<li>数据一旦被读走，便不存在管道中，不可反复读取。</li>
<li>半双工，数据只能在一个方向上流动。</li>
<li>只能在有公共祖先的进程间使用。</li>
</ul>
<p>查看系统用户所有限制值的命令：<code>ulimit -a</code></p>
<pre class=" language-lang-shell"><code class="language-lang-shell">root@iZwz94euuu9omhoocm3l5uZ:~# ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7725
max locked memory       (kbytes, -l) 65536
max memory size         (kbytes, -m) unlimited
open files                      (-n) 65535
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 7725
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
</code></pre>
<p><code>pipe size = 512bytes * 8 = 4KBytes</code>    ,512bytes为磁盘的一个扇区大小。</p>
<h3 id="1-2pipe函数"><a href="#1-2pipe函数" class="headerlink" title="1.2pipe函数"></a>1.2pipe函数</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <sys/wait.h>
int pipe(int pipefd[2]);
</code></pre>
<ul>
<li>参数：<code>pipefd[0]</code>为读端，<code>pipefd[1]</code>为写端</li>
<li>返回值：成功：0；失败：-1，设置errno</li>
</ul>
<h3 id="1-3例子"><a href="#1-3例子" class="headerlink" title="1.3例子"></a>1.3例子</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
int main(void)
&#123;
  int fd[2];
  pid_t pid;

  int ret = pipe(fd);
  if(ret == -1)
  &#123;
    perror("pipe error:");
    exit(1);
  &#125;
  pid = fork();
  if(pid == -1)
  &#123;
    perror("fork error:");
    exit(1);
  &#125;
  else if(pid == 0) // 子进程 读数据
  &#123;

    char buf[1024] = &#123;0&#125;;
    close(fd[1]);
    ret = read(fd[0], buf, sizeof(buf));
    if(ret == 0)
    &#123;
      printf("----\n");
    &#125;
    write(STDOUT_FILENO, buf, ret);
    close(fd[0]);
  &#125;
  else // 父进程 写数据
  &#123;
    close(fd[0]);
    char *data = "hello pipe\n";
    printf("len = %ld\n", sizeof(data));
    write(fd[1], data, strlen(data));
    wait(NULL); // 阻塞回收子线程资源，避免子进程成为僵尸进程
    close(fd[1]);

  &#125;

  return 0;
&#125;
</code></pre>
<h3 id="1-4读写管道的特点"><a href="#1-4读写管道的特点" class="headerlink" title="1.4读写管道的特点"></a>1.4读写管道的特点</h3><ul>
<li><p>读管道：</p>
<ul>
<li><p>管道中有数据，read返回实际读到的字节数。</p>
</li>
<li><p>管道中无数据：</p>
<ul>
<li><p>管道写端被全部关闭，read返回0 (好像读到文件结尾)</p>
</li>
<li><p>写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>写管道： </p>
<ul>
<li>管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</li>
<li>管道读端没有全部关闭：<ul>
<li>管道已满，write阻塞。</li>
<li>管道未满，write将数据写入，并返回实际写入的字节数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2、共享内存"><a href="#2、共享内存" class="headerlink" title="2、共享内存"></a>2、共享内存</h2><h3 id="2-1基本概念"><a href="#2-1基本概念" class="headerlink" title="2.1基本概念"></a>2.1基本概念</h3><p>共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但其它的多个进程<br>都可以访问，使得多个进程可以访问同一块内存空间。</p>
<p>特点：</p>
<ul>
<li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li>
<li>管道和消息队列等通信方式，需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存，另一次从共享内存到输出文件。</li>
<li>因为多个进程可以同时操作，所以需要进行同步。</li>
<li>一般和信号量一起使用，信号量用来同步对共享内存的访问。</li>
</ul>
<h3 id="2-2相关函数"><a href="#2-2相关函数" class="headerlink" title="2.2相关函数"></a>2.2相关函数</h3><p><strong>创建共享内存映射</strong>：</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
</code></pre>
<p>参数：</p>
<ul>
<li><p>addr：建立映射区的首地址，由Linux内核指定。使用时，写NULL即可。</p>
</li>
<li><p>length：要创建映射区的大小。</p>
</li>
<li><p>prot：映射区权限 <code>PORT_READ</code> 、<code>PORT_WRITE</code>、 <code>PORT_READ | PORT_WRITE</code>。</p>
</li>
<li><p>flags：标志位参数（常用于设定更新物理地址、设置共享、创建匿名映射区）。</p>
<p>​            <code>MAP_SHARED</code>：将映射区所做的操作反映到物理设备（磁盘）上。</p>
<p>​            <code>MAP_PRIVATE</code>：映射区所做的修改不会反映到物理设备上。</p>
</li>
<li><p>fd：用来建立映射区的文件描述符。</p>
</li>
<li><p>offset：映射文件的偏移（一定要是4k的整数倍）。</p>
</li>
</ul>
<p>返回值：成功返回创建的映射区首地址；失败返回<code>MAP_FAILED</code>宏。</p>
<p><strong>解除共享内存映射</strong>：</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/mman.h>
int munmap(void *addr, size_t length);
</code></pre>
<p>参数：</p>
<ul>
<li>addr：映射区的首地址。</li>
<li>length：映射区的大小。</li>
</ul>
<p>返回值：成功返回0；失败返回-1。</p>
<p><strong>一定要注意：</strong></p>
<ol>
<li>创建映射区的时候，隐含着一次对映射文件的读操作。</li>
<li>当<code>MAP_SHARED</code>时，要求：映射区的权限应 &lt;= 文件打开的权限（出于对映射区的保护）。而<code>MAP_PRIVATE</code>则无所谓，因为<code>mmap</code> 中的权限是对内存的限制。</li>
<li>映射区的释放和文件关闭无关。只要映射成功，文件可以立刻关闭。</li>
<li>特别注意：当映射文件大小为0时，不能创建映射区。所以：用于映射的文件必须要有实际的大小！！！<code>mmap</code>使用时常出现总线错误，通常是因为共享文件存储空间大小引起的。</li>
<li><code>munmap</code>传入的地址一定要是<code>mmap</code>返回的地址。坚决杜绝指针++操作。</li>
<li>如果文件偏移量必须为4k的整数倍。</li>
<li><code>mmap</code>创建的映射区出错概率非常高，一定要检查返回值，确保映射区建立成功后才进行后续操作。</li>
</ol>
<h3 id="2-3例子"><a href="#2-3例子" class="headerlink" title="2.3例子"></a>2.3例子</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <string.h>

#define MY_MMAP_SIZE 20
#define MY_MMAP_FILE "temp"

int main(void)
&#123;
    char *p = NULL;
    pid_t pid;

    int fd;
    fd = open(MY_MMAP_FILE, O_RDWR|O_CREAT|O_TRUNC, 0644);
    if(fd < 0)&#123;
        perror("open error");
        exit(1);
    &#125;
    unlink(MY_MMAP_FILE);        //删除临时文件目录项
    ftruncate(fd, MY_MMAP_SIZE);
    p = (char *)mmap(NULL, MY_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if(p == MAP_FAILED) &#123; // 注意，不是 p == NULL
        perror("mmap error");
    exit(1);
    &#125;
    close(fd);                   //映射区建立完毕,即可关闭文件

    pid = fork();                               //创建子进程
    if(pid == 0)&#123;
       char *data = "child hello!\n";
        strncpy(p, data, strlen(data) + 1);
       // *p = 1234;
        printf("son, *p = %s\n", p);
    &#125; else &#123;
        sleep(1);
        printf("parent, *p = %s\n", p);
        wait(NULL);

        int ret = munmap(p, MY_MMAP_SIZE);                 //释放映射区
        if (ret == -1) &#123;
            perror("munmap error");
            exit(1);
        &#125;
    &#125;

    return 0;
&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// 匿名映射方式，不要创建临时文件temp
// MAP_ANONYMOUS linux下才有此宏，类unix系统没有
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <string.h>

#define MY_MMAP_SIZE 20

int main(void)
&#123;
    char *p = NULL;
    pid_t pid;

    p = (char *)mmap(NULL, MY_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if(p == MAP_FAILED) &#123; // 注意，不是 p == NULL
        perror("mmap error");
    exit(1);
    &#125;

    pid = fork();                               //创建子进程
    if(pid == 0)&#123;
       char *data = "child hello!\n";
        strncpy(p, data, strlen(data) + 1);
       // *p = 1234;
        printf("son, *p = %s\n", p);
    &#125; else &#123;
        sleep(1);
        printf("parent, *p = %s\n", p);
        wait(NULL);

        int ret = munmap(p, MY_MMAP_SIZE);                 //释放映射区
        if (ret == -1) &#123;
            perror("munmap error");
            exit(1);
        &#125;
    &#125;

    return 0;
&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// 类unix系统的匿名映射方法，Linux也可以使用
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <string.h>

#define MY_MMAP_SIZE 20
#define MY_MMAP_FILE "/dev/zero"

int main(void)
&#123;
    char *p = NULL;
    pid_t pid;

    int fd;
    fd = open(MY_MMAP_FILE, O_RDWR);
    if(fd < 0)&#123;
        perror("open error");
        exit(1);
    &#125;

    p = (char *)mmap(NULL, MY_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if(p == MAP_FAILED) &#123; // 注意，不是 p == NULL
        perror("mmap error");
    exit(1);
    &#125;
    close(fd);                   //映射区建立完毕,即可关闭文件

    pid = fork();                               //创建子进程
    if(pid == 0)&#123;
       char *data = "child hello!\n";
        strncpy(p, data, strlen(data) + 1);
       // *p = 1234;
        printf("son, *p = %s\n", p);
    &#125; else &#123;
        sleep(1);
        printf("parent, *p = %s\n", p);
        wait(NULL);

        int ret = munmap(p, MY_MMAP_SIZE);                 //释放映射区
        if (ret == -1) &#123;
            perror("munmap error");
            exit(1);
        &#125;
    &#125;

    return 0;
&#125;
</code></pre>
<ul>
<li><code>/dev/zero</code>：在类UNIX 操作系统中, <code>/dev/zero</code> 是一个伪文件。<ul>
<li>产生连续不断的null的流 （二进制的零流，而不是ASCII型的）。</li>
<li>写入它的输出会丢失不见 。</li>
<li>主要的用处是用来创建一个指定长度用于初始化的空文件，像临时交换文件。</li>
<li>为特定的目的而用零去填充一个指定大小的文件，如挂载一个文件系统到环回设备 （<code>loopback device</code>） 或”安全地” 删除一个文件。</li>
</ul>
</li>
<li><code>/dev/null</code>：在类Unix系统中，<code>/dev/null</code>，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个<code>EOF</code>。<ul>
<li>被称为位桶(<code>bit bucket</code>)或者黑洞(<code>black hole</code>)。</li>
<li>通常被用于丢弃不需要的输出流，或作为用于输入流的空文件。这些操作通常由重定向完成。</li>
<li>等价于一个只写文件，并且所有写入它的内容都会永远丢失，而尝试从它那儿读取内容则什么也读不到。</li>
<li><code>cat $filename &gt;/dev/nul</code>l 则不会得到任何信息，因为我们将本来该通过标准输出显示的文件信息重定向到了 <code>/dev/null</code> 中。</li>
</ul>
</li>
</ul>
<pre class=" language-lang-c"><code class="language-lang-c">// mmap_wr.c
#include<stdio.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>
#include<sys/mman.h>


struct STU&#123;
    int id;
    char name[20];
    char sex;
&#125;;


void sys_err(char *str)
&#123;
    perror(str);
    exit(1);
&#125;

int main(int argc,char *argv[])
&#123;
    int fd;
    struct STU student = &#123;10, "xiaoming", 'm'&#125;;
    struct STU *mm;


    if(argc < 2)&#123;
        printf("./a.out file_shared\n");
        exit(-1);
    &#125;


    fd = open(argv[1],O_RDWR | O_CREAT, 0664);
    ftruncate(fd,sizeof(student));


    mm = mmap(NULL, sizeof(student), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if (mm == MAP_FAILED)
        sys_err("mmap error");


    close(fd);


    while (1) &#123;
        memcpy(mm, &student, sizeof(student));
        student.id++;
        sleep(1);
    &#125;


    munmap(mm, sizeof(student));
    return 0;
&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// mmap_rd.c
#include<stdio.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>
#include<sys/mman.h>


struct STU&#123;
    int id;
    char name[20];
    char sex;
&#125;;


void sys_err(char *str)
&#123;
    perror(str);
    exit(1);
&#125;


int main(int argc,char *argv[])
&#123;
    int fd;
    struct STU student;
    struct STU *mm;


    if(argc < 2)&#123;
        printf("./a.out file_shared\n");
        exit(-1);
    &#125;


    fd = open(argv[1],O_RDONLY);
    if (fd == -1)
    sys_err("open error");

    mm = mmap(NULL,sizeof(student),PROT_READ,MAP_SHARED,fd,0);
    if (mm == MAP_FAILED)
        sys_err("mmap error");


    close(fd);


    while (1) &#123;
        printf("id=%d\tname=%s\t%c\n", mm->id, mm->name, mm->sex);
        sleep(2);
    &#125;
    munmap(mm, sizeof(student));
    return 0;


&#125;
</code></pre>
<h2 id="3、套接字（socket）"><a href="#3、套接字（socket）" class="headerlink" title="3、套接字（socket）"></a>3、套接字（socket）</h2><h3 id="3-1基本概念"><a href="#3-1基本概念" class="headerlink" title="3.1基本概念"></a>3.1基本概念</h3><p><code>socket</code>套接字本身是为网络通信而设计的，但后来在<code>socket</code>的框架上发展出一种<code>IPC</code>机制，就是<code>Unix Domain Socket</code>。使用<code>Unix Domain Socket</code>的过程跟网络<code>socket</code>十分相似，也要先调用<code>socket()</code>创建一个<code>socket</code>文件描述符，<code>address_family</code>指定为<code>AF_UNIX</code>，<code>type</code>可以选择<code>SOCK_DGRAM</code>或者<code>SOCK_STREAM</code>，<code>protocol</code>参数仍然指定为0即可。</p>
<p><code>Unix Domain Socket</code>与网络<code>socket</code>编程的区别。</p>
<ul>
<li><p><code>Unix Domain Socket</code>：。</p>
<ul>
<li><p>地址格式结构体为<code>sockaddr_un</code>，<code>un</code>表示Unix。</p>
</li>
<li><p>地址是一个<code>socket</code>类型的文件在文件系统中的路径，这个<code>socket</code>文件由<code>bind()</code>调用创建，如果调用<code>bind()</code>时该文件已存在，则<code>bind()</code>错误返回。</p>
<pre class=" language-lang-c"><code class="language-lang-c">struct sockaddr_un &#123;
   __kernel_sa_family sun_family;   /* AF_UNIX */  地址结构类型
   char sun_path[UNIX_PATH_MAX];    /* pathname */ socket文件名（含路径）
&#125;;
</code></pre>
</li>
<li><p>将<code>Unix Domain socket</code>绑定到一个地址。</p>
<pre class=" language-lang-c"><code class="language-lang-c">size = offsetof(struct sockaddr_un, sunpath) + strlen(un.sun_path);
#define offsetof(type, member) ((int)&((type *)0)->MEMBER)
</code></pre>
</li>
</ul>
</li>
<li><p>网络<code>socket</code>编程：</p>
<ul>
<li><p>地址格式结构体为<code>sockaddr_in</code>，<code>in</code>表示Internet。</p>
</li>
<li><p>地址是IP地址加上端口号。</p>
<pre class=" language-lang-c"><code class="language-lang-c">struct sockaddr_in &#123;
    __kernel_sa_family_t sin_family; /* Address family */  地址结构类型
    __be16 sin_port;                 /* Port number */     端口号
    struct in_addr sin_addr;         /* Internet address */ip地址
&#125;;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="3-2例子"><a href="#3-2例子" class="headerlink" title="3.2例子"></a>3.2例子</h3><pre class=" language-lang-c"><code class="language-lang-c">// socket_server.c
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <string.h>
#include <strings.h>
#include <ctype.h>
#include <sys/un.h>
#include <stdlib.h>
#include "wrap.h"
#define SERVER_ADDR "server.socket"
#define SERVER_CONNECT_MAX 20

#define rdbuf_size 4096

int main(void)
&#123;
  int lfd, cfd, len, size;
  struct sockaddr_un serveraddr, clientaddr;
  char rdbuf[rdbuf_size] = &#123;0&#125;;

  lfd = Socket(AF_UNIX, SOCK_STREAM, 0);

  bzero(&serveraddr, sizeof(serveraddr));
  serveraddr.sun_family = AF_UNIX;
  strncpy(serveraddr.sun_path, SERVER_ADDR, sizeof(SERVER_ADDR));

  len = offsetof(struct sockaddr_un, sun_path) + strlen(serveraddr.sun_path); // serveraddr total len

  unlink(SERVER_ADDR);    // 确保bind之前 server.socket 文件不存在，bind() 会创建该文件
  Bind(lfd, (struct sockaddr *)&serveraddr, len); // 参3不能是 sizeof(serveraddr)

  Listen(lfd, SERVER_CONNECT_MAX);

  printf("Accept...\n");

  while(1)
  &#123;
    len = sizeof(clientaddr); // 好像不用这句也行
    cfd = Accept(lfd, (struct sockaddr *)&clientaddr, (socklen_t *)&len);

    len -= offsetof(struct sockaddr_un, sun_path); // 等到文件名的长度
    clientaddr.sun_path[len] = '\0'; // 确保打印时没有乱码

    printf("client bind filename %s \n", clientaddr.sun_path);

    while((size = read(cfd, rdbuf, rdbuf_size)) > 0)
    &#123;
      for(int i = 0; i < size; i++)
              rdbuf[i] = toupper(rdbuf[i]);
      int tmp = size;
      do &#123;
        int tmp2 = write(cfd, rdbuf, tmp);
        if(tmp2 == -1)
        &#123;
                perror("write error:");
                break;
        &#125;
        tmp -= tmp2; 
      &#125; while(tmp > 0);
    &#125;
    close(cfd);
  &#125;
  close(lfd);

  return 0;

&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// socket_client.c
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <string.h>
#include <strings.h>
#include <ctype.h>
#include <sys/un.h>
#include "wrap.h"

#define SERVER_ADDR "server.socket"
#define CLIENT_ADDR "client.socket"
#define FGETS_BUF_SIZE 4096


int main(void)
&#123;
  int cfd, len;
  struct sockaddr_un serveraddr, clientaddr;
  char buf[FGETS_BUF_SIZE] = &#123;0&#125;;

  cfd = Socket(AF_UNIX, SOCK_STREAM, 0);

  bzero(&clientaddr, sizeof(clientaddr));
  clientaddr.sun_family = AF_UNIX;
  strncpy(clientaddr.sun_path, CLIENT_ADDR, sizeof(CLIENT_ADDR));

  len = offsetof(struct sockaddr_un, sun_path) + strlen(clientaddr.sun_path); // 计算客户端地质结构有效长度

  unlink(CLIENT_ADDR);
  Bind(cfd, (struct sockaddr *)&clientaddr, len); // 客户端也需要bind，不能依赖自动绑定

  bzero(&serveraddr, sizeof(serveraddr));  // 构造server地址
  serveraddr.sun_family = AF_UNIX;
  strncpy(serveraddr.sun_path, SERVER_ADDR, sizeof(SERVER_ADDR));

  len = offsetof(struct sockaddr_un, sun_path) + strlen(serveraddr.sun_path); //计算服务器地址结构有效长度

  Connect(cfd, (struct sockaddr *)&serveraddr, len);

  while(fgets(buf, sizeof(buf), stdin) != NULL)
  &#123;
    write(cfd, buf, strlen(buf));
    len = read(cfd, buf, sizeof(buf));
    write(STDOUT_FILENO, buf, len);

  &#125;
  close(cfd);

&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// wrap.c 这里是socket的包裹函数
#include <stdio.h>
#include <wrap.h>
void err_sys(const char* x) 
&#123; 
    perror(x); 
    exit(1); 
&#125;

int Socket(int domain, int type, int protocol)
&#123;
  int n;
  if ((n = socket(domain, type, protocol)) < 0)
    err_sys("socket error");
  return (n);
&#125;

int Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
&#123;
  int n;
  if ((n = bind(sockfd, addr, addrlen)) < 0)
    err_sys("bind error");
  return (n);

&#125;

int Listen(int sockfd, int backlog)
&#123;
  int n;
  if ((n = listen(sockfd, backlog)) < 0)
    err_sys("listen error");
  return (n);

&#125;

int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
&#123;
  int n;
  if ((n = accept(sockfd, addr, addrlen)) < 0)
    err_sys("accept error");
  return (n);

&#125;

int Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
&#123;
  int n;
  if ((n = connect(sockfd, addr, addrlen)) < 0)
    err_sys("connect error");
  return (n);

&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// wrap.h
#ifndef __WRAP_H
#define __WRAP_H

#include <stdlib.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

#define offsetof(type, member) ((int)&((type *)0)->member)

int Socket(int domain, int type, int protocol);
int Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int Listen(int sockfd, int backlog);
int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
int Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

#endif
</code></pre>
<pre class=" language-lang-makefile"><code class="language-lang-makefile"># 这个makefile写不是很好，有待整改
all : socket_client socket_server
.PHONY : all

RM_TARGET = socket_client socket_server

CLIENT_OBJS = socket_client.o wrap.o
SERVER_OBJS = socket_server.o wrap.o

# LIBS := -lpthread
CFLAGS = -I. -g
CC = gcc
CXX = g++

socket_client : $(CLIENT_OBJS)
    $(CC) -o socket_client $(CLIENT_OBJS) $(CFLAGS) $(LIBS)

socket_server : $(SERVER_OBJS)
    $(CC) -o socket_server $(SERVER_OBJS) $(CFLAGS) $(LIBS)

$(CLIENT_OBJS) : %.o : %.c
    $(CC) -c $(CFLAGS) $< -o $@

$(SERVER_OBJS) : %.o : %.c
    $(CC) -c $(CFLAGS) $< -o $@

.PHONY : clean
clean :
    -$(RM) socket_server socket_client  $(CLIENT_OBJS) $(SERVER_OBJS)
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title>信号</title>
    <url>/2021/07/05/signal/</url>
    <content><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="1、信号的概念"><a href="#1、信号的概念" class="headerlink" title="1、信号的概念"></a>1、信号的概念</h2><h3 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h3><ol>
<li>简单。</li>
<li>不能携带大量信息。</li>
<li>满足某个特设条件才能发送。</li>
</ol>
<h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>A给B发送信号，B收到信号前执行自己的代码，收到信号好后，不管执行到程序的什么位置，都要暂停运行， 去处理信号，处理完毕再继续运行。与硬件中断类似，但信号是软件层面上实现的终端，常称为“软中断”。</p>
<blockquote>
<p><strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></p>
</blockquote>
<h3 id="阻塞信号集（信号屏蔽字）"><a href="#阻塞信号集（信号屏蔽字）" class="headerlink" title="阻塞信号集（信号屏蔽字）"></a>阻塞信号集（信号屏蔽字）</h3><p>将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后（解除屏蔽后），<code>未决信号集</code>的对应信号位置将不再立刻翻转，常为1。</p>
<h3 id="未决信号集"><a href="#未决信号集" class="headerlink" title="未决信号集"></a>未决信号集</h3><ol>
<li>信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理，对应位翻转回0。这一时刻“光速”。</li>
<li>信号产生后由于某些原因（主要是阻塞）不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</li>
</ol>
<h3 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a>信号的编号</h3><pre class=" language-lang-shell"><code class="language-lang-shell">cyh@cyh-virtual-machine:~$kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
</code></pre>
<ul>
<li><p>1-31为普通信号（常规信号）。</p>
<ul>
<li>常用2、3、7、8、9、10、11、12、13、14、15、17、19、20号信号</li>
</ul>
</li>
<li><p>34-64为实时信号，一般是在嵌入式驱动开发中才用得到，应用层开发一般不用。</p>
</li>
</ul>
<p>可通过<code>man 7 signal</code>查看详细说明</p>
<pre class=" language-lang-c"><code class="language-lang-c">Signal      Standard   Action   Comment
────────────────────────────────────────────────────────────────────────
SIGABRT      P1990      Core    Abort signal from abort(3)
SIGALRM      P1990      Term    Timer signal from alarm(2)
SIGBUS       P2001      Core    Bus error (bad memory access)
SIGCHLD      P1990      Ign     Child stopped or terminated
SIGCLD         -        Ign     A synonym for SIGCHLD
SIGCONT      P1990      Cont    Continue if stopped
SIGEMT         -        Term    Emulator trap
SIGFPE       P1990      Core    Floating-point exception
SIGHUP       P1990      Term    Hangup detected on controlling terminal
                               or death of controlling process
SIGILL       P1990      Core    Illegal Instruction
SIGINFO        -                A synonym for SIGPWR
SIGINT       P1990      Term    Interrupt from keyboard
SIGIO          -        Term    I/O now possible (4.2BSD)
SIGIOT         -        Core    IOT trap. A synonym for SIGABRT
SIGKILL      P1990      Term    Kill signal
SIGLOST        -        Term    File lock lost (unused)
SIGPIPE      P1990      Term    Broken pipe: write to pipe with no
                               readers; see pipe(7)
SIGPOLL      P2001      Term    Pollable event (Sys V).
                               Synonym for SIGIO
SIGPROF      P2001      Term    Profiling timer expired
SIGPWR         -        Term    Power failure (System V)
SIGQUIT      P1990      Core    Quit from keyboard
SIGSEGV      P1990      Core    Invalid memory reference
SIGSTKFLT      -        Term    Stack fault on coprocessor (unused)
SIGSTOP      P1990      Stop    Stop process
SIGTSTP      P1990      Stop    Stop typed at terminal
SIGSYS       P2001      Core    Bad system call (SVr4);
                               see also seccomp(2)
SIGTERM      P1990      Term    Termination signal

SIGTRAP      P2001      Core    Trace/breakpoint trap
SIGTTIN      P1990      Stop    Terminal input for background process
SIGTTOU      P1990      Stop    Terminal output for background process
SIGUNUSED      -        Core    Synonymous with SIGSYS
SIGURG       P2001      Ign     Urgent condition on socket (4.2BSD)
SIGUSR1      P1990      Term    User-defined signal 1
SIGUSR2      P1990      Term    User-defined signal 2
SIGVTALRM    P2001      Term    Virtual alarm clock (4.2BSD)
SIGXCPU      P2001      Core    CPU time limit exceeded (4.2BSD);
                               see setrlimit(2)
SIGXFSZ      P2001      Core    File size limit exceeded (4.2BSD);
                               see setrlimit(2)
SIGWINCH       -        Ign     Window resize signal (4.3BSD, Sun)

The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.
//9)SIGKILL、19)SIGSTOP信号，不允许忽略或者捕获，只能执行默认动作。甚至不能将其阻塞。
</code></pre>
<pre><code>Signal        x86/ARM     Alpha/   MIPS   PARISC   Notes
           most others   SPARC
─────────────────────────────────────────────────────────────────
SIGHUP           1           1       1       1
SIGINT           2           2       2       2
SIGQUIT          3           3       3       3
SIGILL           4           4       4       4
SIGTRAP          5           5       5       5
SIGABRT          6           6       6       6
SIGIOT           6           6       6       6
SIGBUS           7          10      10      10
SIGEMT           -           7       7      -
SIGFPE           8           8       8       8
SIGKILL          9           9       9       9
SIGUSR1         10          30      16      16
SIGSEGV         11          11      11      11
SIGUSR2         12          31      17      17
SIGPIPE         13          13      13      13
SIGALRM         14          14      14      14
SIGTERM         15          15      15      15
SIGSTKFLT       16          -       -        7
SIGCHLD         17          20      18      18
SIGCLD           -          -       18      -
SIGCONT         18          19      25      26
SIGSTOP         19          17      23      24

SIGTSTP         20          18      24      25
SIGTTIN         21          21      26      27
SIGTTOU         22          22      27      28
SIGURG          23          16      21      29
SIGXCPU         24          24      30      12
SIGXFSZ         25          25      31      30
SIGVTALRM       26          26      28      20
SIGPROF         27          27      29      21
SIGWINCH        28          28      20      23
SIGIO           29          23      22      22
SIGPOLL                                            Same as SIGIO
SIGPWR          30         29/-     19      19
SIGINFO          -         29/-     -       -
SIGLOST          -         -/29     -       -
SIGSYS          31          12      12      31
SIGUNUSED       31          -       -       31
</code></pre><h3 id="默认动作"><a href="#默认动作" class="headerlink" title="默认动作"></a>默认动作</h3><ul>
<li>Term：终止进程，如kill。</li>
<li>Ign：忽略信号（默认即时对该信号忽略操作），如子进程退出时通知父进程的“收尸”信号。</li>
<li>Core：终止进程，生成Core文件。（查验进程死亡原因，用于gdb调试）</li>
<li>Stop：停止（暂停）进程。</li>
<li>Cont：继续运行进程</li>
</ul>
<blockquote>
<p>注意：只有每个信号所对应的事件发生了，该信号才会被递送（但不一定递达），不应该乱发信号！</p>
</blockquote>
<h3 id="信号的处理方式"><a href="#信号的处理方式" class="headerlink" title="信号的处理方式"></a>信号的处理方式</h3><ol>
<li>执行默认动作</li>
<li>忽略（丢弃）</li>
<li>捕捉（调用用户处理函数）</li>
</ol>
<h3 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h3><ol>
<li>编号</li>
<li>名称</li>
<li>事件</li>
<li>默认处理动作</li>
</ol>
<h3 id="产生信号5种方式"><a href="#产生信号5种方式" class="headerlink" title="产生信号5种方式"></a>产生信号5种方式</h3><ol>
<li>按键产生： 2) SIGINT <code>Ctrl+c</code>、20) SIGTSTP <code>Ctrl+z</code>、3) SIGQUIT <code>Ctrl+\</code></li>
<li>系统调用：<code>kill()</code>、<code>raise()</code> 、<code>abort()</code></li>
<li>软件条件产生：定时器alarm</li>
<li>硬件异常产生：非法访问内存（段错误）、除0（浮点数例外）、内存对齐出错（总线错误）</li>
<li>命令产生：kill - 9</li>
</ol>
<h2 id="2、信号产生函数"><a href="#2、信号产生函数" class="headerlink" title="2、信号产生函数"></a>2、信号产生函数</h2><h3 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
</code></pre>
<p>参数：</p>
<ul>
<li><p>pid：进程id</p>
<p>pid &gt;0：发送信号给指定进程。</p>
<p>pid=0：发送信号给 与 调用kill()函数进程属于同一进程组的所有进程。</p>
<p>pid&lt;0：取pid的绝对值|pid|发送给对应进程组。</p>
<p>pid=-1：发送给进程所有权限发送的系统中所有进程。</p>
<p>进程组：每个进程都属于一个进程组，进程组是一个或者多个进程的集合，相互关联，共同完成一个用户概念的任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p>
<p>权限保护：super用户（root）可以发送信号给任何用户，普通用户不能向系统用户发送 信号，在普通用户中，使用<code>kill -9 (root用户的pid)</code>是不能成功的，同时，普通用户也不能给其他普通用户发送信号，终止其进程。只能向自己创建的进程发送信号。普通用户基本原则：发送者实际或有效用户ID == 接收者实际或有效用户ID。</p>
</li>
<li><p>sig：信号类型</p>
</li>
</ul>
<p>返回值：成功返回0，失败返回-1。</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">$ ps ajx
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
      0       1       1       1 ?             -1 Ss       0   0:08 /sbin/init splash
      0       2       0       0 ?             -1 S        0   0:00 [kthreadd]
      2       3       0       0 ?             -1 I<       0   0:00 [rcu_gp]
</code></pre>
<p>父进程ID(PPID)，进程ID(PID )，进程组ID(PGID)，会话组ID(SID)。</p>
<h3 id="raise-和abort"><a href="#raise-和abort" class="headerlink" title="raise()和abort()"></a>raise()和abort()</h3><p>raise函数：给当前进程发送指定信号（自发自收）。raise(signo) == kill(getpid(), signo);</p>
<p>​        int raise(int sig); 成功返回0，失败返回非0值。</p>
<p>abort函数：给自己发送异常终止信号 6) SIGABRT 信号，终止并产生core文件。</p>
<p>​        void abort(void); </p>
<h3 id="alaram"><a href="#alaram" class="headerlink" title="alaram()"></a>alaram()</h3><p>设置定时器，在指定seconds后，内核会给当前进程发送 14) SIGALRM 信号。进程收到该信号，默认终止进程。</p>
<p><strong>注意：每个进程有且只有一个定时器。</strong></p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <unistd.h>
unsigned int alarm(unsigned int seconds); // 返回0或者上一次定时剩余的秒数，不会失败。
</code></pre>
<p>常用alram(0)来取消定时器。</p>
<p><strong>与进程状态无关的自然定时法！！</strong>无论进程处于就绪、运行、挂起（阻塞、暂停）、终止、僵尸…alarm都计时而不会被打断。</p>
<pre class=" language-lang-c"><code class="language-lang-c">// 统计1秒内计算机能数多少个数。
#include <stdio.h>
#include <unistd.h>

int main(void)
&#123;
  alarm(1);
  for(int i = 0; ; i++)
  &#123;
    printf("%d \n", i);
  &#125;
  return 0;
&#125;
</code></pre>
<pre class=" language-lang-shell"><code class="language-lang-shell">$ time ./a.out  > cnt    //应用程序前加time可以统计一个程序的运行时间， > cnt 表示输出重定向到文件cnt 
...
real    0m1.082s
user    0m0.022s    // 程序在用户空间的时间
sys     0m0.986s    // 程序在内核空间的时间
</code></pre>
<h3 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer()"></a>setitimer()</h3><p>设置定时器，可替代alarm函数。精度微妙us。可以实现周期性定时。</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/time.h>
struct itimerval &#123;
    struct timeval it_interval; /* Interval for periodic timer 两次定时的间隔时间*/
    struct timeval it_value;    /* Time until next expiration 定时的时长*/
&#125;;
struct timeval &#123;
    time_t      tv_sec;         /* seconds */
    suseconds_t tv_usec;        /* microseconds */
&#125;;
int getitimer(int which, struct itimerval *curr_value);
int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);
</code></pre>
<p>参数：</p>
<ul>
<li><p>which：指定定时方式</p>
<ol>
<li>自然定时：ITIMER ==&gt; 14) SIGLARM                                                      计算自然时间</li>
<li>虚拟空间计时（用户空间）：ITIMER_VIRTUAL ==&gt; 26) SIGVTALRM  只计算进程占用cpu的时间</li>
<li>运行时计时（用户+内核）：ITIMER_PROF ==&gt; 27) SIGPROF              计算占用cpu和执行系统调用的时间</li>
</ol>
</li>
<li><p>new_value：定时的时间</p>
</li>
<li>old_value：上次定时剩余的时间</li>
</ul>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>

unsigned int my_alarm(unsigned int sec)
&#123;
  struct itimerval it, lastit;

  it.it_value.tv_sec = sec;
  it.it_value.tv_usec = 0;
  it.it_interval.tv_sec = 0;
  it.it_interval.tv_usec = 0;

  int ret = setitimer(ITIMER_REAL, &it, &lastit);
  if(ret == -1)
  &#123;
    perror("setitimer");
    exit(1);
  &#125;

  return lastit.it_value.tv_sec;

&#125;
int main(void)
&#123;
  my_alarm(1);
  for(int i = 0; ; i++)
  &#123;
    printf("%d \n", i);
  &#125;
  return 0;
&#125;
</code></pre>
<h2 id="3、信号捕捉函数"><a href="#3、信号捕捉函数" class="headerlink" title="3、信号捕捉函数"></a>3、信号捕捉函数</h2><h3 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
</code></pre>
<p>参数：signum，信号；handler，信号的回调函数，想让该信号进行的处理放这个回调函数里的。</p>
<p>返回值：成功返回信号处理程序的前一个值，失败返回SIG_ERR。</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/time.h>
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

// 此函数运行在用户空间，由内核调用
// 函数返回时执行特殊的系统调用sigreturn再次进入内核
void func(int sigo)
&#123;
  printf("hello signal SIGALRM!\n");
&#125;
int main(void)
&#123;
  struct itimerval it, lastit;

  signal(SIGALRM, func); // 注册SIGALRM信号的捕捉处理函数

  it.it_value.tv_sec = 5;    //第一次定时5s
  it.it_value.tv_usec = 0;

  it.it_interval.tv_sec = 3;  // 后面都是定时3s
  it.it_interval.tv_usec = 0;

  int ret = setitimer(ITIMER_REAL, &it, &lastit);
  if(ret == -1)
  &#123;
    perror("setitimer");
    exit(1);
  &#125;

  while(1);
  return 0;
&#125;
</code></pre>
<h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction()"></a>sigaction()</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <signal.h>
struct sigaction &#123;
    void     (*sa_handler)(int);  // 回调函数
    void     (*sa_sigaction)(int, siginfo_t *, void *); 
    sigset_t   sa_mask; // 信号捕捉函数期间的信号屏蔽字
    int        sa_flags;  
    void     (*sa_restorer)(void); // 已废弃，不看
&#125;;

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
</code></pre>
<p>sa_restorer：已过时，不应该使用。POSIX.1标准将不指定该元素。（弃用）</p>
<p>sa_sigaction：当sa_flags被指定为SA_SIGINFO标志时，使用该信号处理程序。（很少用）</p>
<p>重点：</p>
<p>sa_handler：指定该信号捕捉后的处理函数名（即注册函数）。也可以赋值为SIG_IGN表示忽略 或 SIG_DFL 表示执行默认动作。</p>
<p>sa_mask：调用信号处理函数时，所要屏蔽的信号集合（信号屏蔽字）。<strong>注意：仅在处理函数被调用期间屏蔽生效，是临时设置</strong>。</p>
<p>sa_flags：一般设置为0，表示使用默认属性。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
void catchsig(int signo)
&#123;
    printf(&quot;%d signal is catched\n&quot;,signo);
&#125;

int main(void)
&#123;
    int ret;
    struct sigaction act;

    act.sa_handler = catchsig;
    sigemptyset(&amp;act.sa_mask);
    sigaddset(&amp;act.sa_mask, SIGQUIT); //  3) SIGQUIT (ctr + \)
    act.sa_flags = 0; // 默认属性 信号捕捉函数执行期间，自动屏蔽本信号

    ret = sigaction(SIGINT, &amp;act, NULL); // 2) SIGINT(ctrl + c)
    if(ret &lt; 0)
    &#123;
        perror(&quot;sigaction error&quot;);
        exit(1);
    &#125;
    while(1);
    return 0;
&#125;
</code></pre><h2 id="4、信号集操作函数"><a href="#4、信号集操作函数" class="headerlink" title="4、信号集操作函数"></a>4、信号集操作函数</h2><p>内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字mask可以影响未决信号集。所以可以通过在应用程序中自定义set来改变mask，从而屏蔽指定信号。</p>
<h3 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a>信号集设定</h3><p>sigset_t    set;    // typdef unsigned long sigset_t; 本质上是位图    </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>int sigemptyset(sigset_t *set);</td>
<td>将某个信号集清零</td>
<td>成功：0；失败：-1</td>
</tr>
<tr>
<td>int sigfillset(sigset_t *set);</td>
<td>将某个信号集置1</td>
<td>成功：0；失败：-1</td>
</tr>
<tr>
<td>int sigaddset(sigset_t set, int signum);</td>
<td>将某个信号加入信号集</td>
<td>成功：0；失败：-1</td>
</tr>
<tr>
<td>int sigdelset(sigset_t set, int signum);</td>
<td>将某个信号清出信号集</td>
<td>成功：0；失败：-1</td>
</tr>
<tr>
<td>int sigismember(const sigset_t *set, int signum);</td>
<td>判断某个信号是否在信号集中</td>
<td>在集合：1；不在：0；出错：-1</td>
</tr>
</tbody>
</table>
</div>
<h3 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h3><p>用来<strong>屏蔽信号</strong>、<strong>解除信号屏蔽</strong>。其本质，读取或者修改进程的信号屏蔽字（pcb中）。</p>
<p><strong>再说一遍，屏蔽信号：只是将信号处理延后执行（延至解除屏蔽）；而忽略表示将信号丢弃。</strong></p>
<p>int sigprocmask(int how, const sigset_t <em>set, sigset_t </em>oldset);    成功：0；失败：-1，设置errno。</p>
<p>参数：</p>
<p>set：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽那个信号。</p>
<p>oldset：传出参数，保存旧的信号屏蔽字。</p>
<p>how：假定当前信号屏蔽字为mask</p>
<ol>
<li>SIG_BLOCK：set表示需要屏蔽的信号，相当 mask |= set</li>
<li>SIG_UNBLOCK：set表示需要解除屏蔽的信号，相当 mask = mask &amp; (~set)</li>
<li>SIG_SETMASK：set用于替代原始屏蔽集的新屏蔽集，相当 mask = set，若调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</li>
</ol>
<h3 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h3><p>读取当前进程的未决信号集。</p>
<p>int sigpending(sigset_t *set);    set：传出参数    返回值：成功：0；失败：-1，设置errno</p>
<pre class=" language-lang-c"><code class="language-lang-c">// 打印当前进程所有的未决信号集
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
void printpend(sigset_t *ped)
&#123;
    int i;
    for(i = 1; i < 32; i++)
    &#123;
        if(sigismember(ped, i) == 1)
        &#123;
            putchar('1');
        &#125;
        else
        &#123;
            putchar('0');
        &#125;
    &#125;
    printf("\n");
&#125;
int main(void)
&#123;
    sigset_t myset, oldset, ped;

    sigemptyset(&myset);  // 清零

    sigaddset(&myset, SIGQUIT); // 将 3) SIGQUIT(ctrl + \) 信号加入到myset信号集
    sigaddset(&myset, SIGINT); // 2) SIGINT(ctrl + c)
    sigaddset(&myset, SIGTSTP); // 20) SIGTSTP(ctrl +z)

    // 9)SIGKILL、19)SIGSTOP信号，不允许忽略或者捕获，只能执行默认动作。甚至不能将其阻塞。
    // 所以下面这两句其实没什么用
    sigaddset(&myset, SIGKILL);
    sigaddset(&myset, SIGSTOP);


    sigprocmask(SIG_BLOCK, &myset, &oldset); // 将myset信号集去影响阻塞信号集

    while(1)&#123;
        sigpending(&ped); // 获取当前进程的未决信号集。
           printpend(&ped);
        sleep(1);
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="5、信号捕捉特性"><a href="#5、信号捕捉特性" class="headerlink" title="5、信号捕捉特性"></a>5、信号捕捉特性</h2><ol>
<li>进程正常运行时，默认PCB中有一个信号屏蔽字，假定为⭐，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号后，要调用该函数。而该函数可能会执行很长时间，在这期间所屏蔽的信号不由⭐来指定，而是由sa_mask来指定。调用完信号处理函数，再恢复为⭐。</li>
<li>xxx信号捕捉函数执行期间，xxx信号自动屏蔽。</li>
<li>阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）</li>
</ol>
<h2 id="6、内核实现信号捕捉过程"><a href="#6、内核实现信号捕捉过程" class="headerlink" title="6、内核实现信号捕捉过程"></a>6、内核实现信号捕捉过程</h2><p><img src="https://i.loli.net/2021/07/05/hFPQlETXJvb3zHe.png" alt="内核实现信号捕捉过程.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>信号</tag>
      </tags>
  </entry>
</search>
