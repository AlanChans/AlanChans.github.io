<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>简单的gdb调试命令</title>
    <url>/2021/07/05/easy-gdb/</url>
    <content><![CDATA[<h1 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h1><p>用表格记录一下常用的gdb调试命令，方便以后使用。只列举了部分的gdb调试命令，但已足够%90的需求。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
<th>简写</th>
<th>详细描述</th>
<th>用例</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动gdb</td>
<td>start</td>
<td></td>
<td>只执行一步</td>
<td></td>
</tr>
<tr>
<td></td>
<td>next</td>
<td>n</td>
<td>单步执行，直接执行完函数体，不进入函数体内部</td>
<td></td>
</tr>
<tr>
<td></td>
<td>step</td>
<td>s</td>
<td>单步执行，可以进入函数体内部</td>
<td></td>
</tr>
<tr>
<td></td>
<td>continue</td>
<td>c</td>
<td>直接执行到断点</td>
<td></td>
</tr>
<tr>
<td>查看代码</td>
<td>list</td>
<td>l</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>l 行号（函数名）</td>
<td>当前文件第几行或函数</td>
<td>l 10</td>
</tr>
<tr>
<td></td>
<td></td>
<td>l 文件名: 行号（函数名）</td>
<td>指定文件第几行或函数</td>
<td>l server.c main</td>
</tr>
<tr>
<td>设置断点</td>
<td>break</td>
<td>b</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>b 行号（函数名）</td>
<td>设置当前文件断点</td>
<td>b 23</td>
</tr>
<tr>
<td></td>
<td></td>
<td>b 文件名:行号（函数名）</td>
<td>设置指定文件断点</td>
<td>b server.c 13</td>
</tr>
<tr>
<td></td>
<td></td>
<td>b 行号 条件</td>
<td>设置条件断点</td>
<td>b 10 if value == 19</td>
</tr>
<tr>
<td>删除断点</td>
<td>delete</td>
<td>del 或者 d</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>d 断点编号</td>
<td></td>
<td>d 1</td>
</tr>
<tr>
<td>获取断点编号</td>
<td>info</td>
<td>i b</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>info b</td>
<td>获取断点编号</td>
<td>info b</td>
</tr>
<tr>
<td>单步调试</td>
<td>step</td>
<td>s</td>
<td>这个单步调试进入到函数体内部</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>finish</td>
<td>从函数体内部跳出</td>
<td></td>
</tr>
<tr>
<td>单步调试</td>
<td>next</td>
<td>n</td>
<td>这个单步调试不会进入到函数体内部</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>u</td>
<td>退出当前循环</td>
<td></td>
</tr>
<tr>
<td>查看变量的值</td>
<td>print</td>
<td>p 变量名</td>
<td></td>
<td></td>
</tr>
<tr>
<td>查看变量的类型</td>
<td>ptype</td>
<td>ptype 变量名</td>
<td></td>
<td></td>
</tr>
<tr>
<td>设置变量的值</td>
<td>set</td>
<td>set var 变量名 = 赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>设置追踪变量</td>
<td>display</td>
<td>display 变量名</td>
<td></td>
<td></td>
</tr>
<tr>
<td>取消追踪变量</td>
<td>undisplay</td>
<td>undisplay 变量编号</td>
<td></td>
<td></td>
</tr>
<tr>
<td>获取变量编号</td>
<td>info</td>
<td>info display</td>
<td></td>
<td></td>
</tr>
<tr>
<td>退出gdb</td>
<td>quit</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信IPC</title>
    <url>/2021/06/29/ipc/</url>
    <content><![CDATA[<h1 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h1><p>IPC（Inter-Process Communication，进程间通信）。进程间通信是指两个进程的数据之间产生交互。</p>
<h2 id="1、管道"><a href="#1、管道" class="headerlink" title="1、管道"></a>1、管道</h2><h3 id="1-1基本概念"><a href="#1-1基本概念" class="headerlink" title="1.1基本概念"></a>1.1基本概念</h3><p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。</p>
<ul>
<li>本质是一个伪文件（实为内核缓冲区）。</li>
<li>有两个文件描述符，一个表示读端(<code>fd[1]</code>)，一个表示写端(<code>fd[0]</code>)。</li>
<li>规定数据从管道的写端流入，从读端流出。</li>
<li>双向半双工。</li>
</ul>
<p>原理：管道实为内核使用环形队列机制，借助内核缓冲区（4k）实现。</p>
<p>缺点：</p>
<ul>
<li>数据只能自己读不能自己写。</li>
<li>数据一旦被读走，便不存在管道中，不可反复读取。</li>
<li>半双工，数据只能在一个方向上流动。</li>
<li>只能在有公共祖先的进程间使用。</li>
</ul>
<p>查看系统用户所有限制值的命令：<code>ulimit -a</code></p>
<pre class=" language-lang-shell"><code class="language-lang-shell">root@iZwz94euuu9omhoocm3l5uZ:~# ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7725
max locked memory       (kbytes, -l) 65536
max memory size         (kbytes, -m) unlimited
open files                      (-n) 65535
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 7725
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
</code></pre>
<p><code>pipe size = 512bytes * 8 = 4KBytes</code>    ,512bytes为磁盘的一个扇区大小。</p>
<h3 id="1-2pipe函数"><a href="#1-2pipe函数" class="headerlink" title="1.2pipe函数"></a>1.2pipe函数</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <sys/wait.h>
int pipe(int pipefd[2]);
</code></pre>
<ul>
<li>参数：<code>pipefd[0]</code>为读端，<code>pipefd[1]</code>为写端</li>
<li>返回值：成功：0；失败：-1，设置errno</li>
</ul>
<h3 id="1-3例子"><a href="#1-3例子" class="headerlink" title="1.3例子"></a>1.3例子</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
int main(void)
&#123;
  int fd[2];
  pid_t pid;

  int ret = pipe(fd);
  if(ret == -1)
  &#123;
    perror("pipe error:");
    exit(1);
  &#125;
  pid = fork();
  if(pid == -1)
  &#123;
    perror("fork error:");
    exit(1);
  &#125;
  else if(pid == 0) // 子进程 读数据
  &#123;

    char buf[1024] = &#123;0&#125;;
    close(fd[1]);
    ret = read(fd[0], buf, sizeof(buf));
    if(ret == 0)
    &#123;
      printf("----\n");
    &#125;
    write(STDOUT_FILENO, buf, ret);
    close(fd[0]);
  &#125;
  else // 父进程 写数据
  &#123;
    close(fd[0]);
    char *data = "hello pipe\n";
    printf("len = %ld\n", sizeof(data));
    write(fd[1], data, strlen(data));
    wait(NULL); // 阻塞回收子线程资源，避免子进程成为僵尸进程
    close(fd[1]);

  &#125;

  return 0;
&#125;
</code></pre>
<h3 id="1-4读写管道的特点"><a href="#1-4读写管道的特点" class="headerlink" title="1.4读写管道的特点"></a>1.4读写管道的特点</h3><ul>
<li><p>读管道：</p>
<ul>
<li><p>管道中有数据，read返回实际读到的字节数。</p>
</li>
<li><p>管道中无数据：</p>
<ul>
<li><p>管道写端被全部关闭，read返回0 (好像读到文件结尾)</p>
</li>
<li><p>写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>写管道： </p>
<ul>
<li>管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</li>
<li>管道读端没有全部关闭：<ul>
<li>管道已满，write阻塞。</li>
<li>管道未满，write将数据写入，并返回实际写入的字节数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2、共享内存"><a href="#2、共享内存" class="headerlink" title="2、共享内存"></a>2、共享内存</h2><h3 id="2-1基本概念"><a href="#2-1基本概念" class="headerlink" title="2.1基本概念"></a>2.1基本概念</h3><p>共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但其它的多个进程<br>都可以访问，使得多个进程可以访问同一块内存空间。</p>
<p>特点：</p>
<ul>
<li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li>
<li>管道和消息队列等通信方式，需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存，另一次从共享内存到输出文件。</li>
<li>因为多个进程可以同时操作，所以需要进行同步。</li>
<li>一般和信号量一起使用，信号量用来同步对共享内存的访问。</li>
</ul>
<h3 id="2-2相关函数"><a href="#2-2相关函数" class="headerlink" title="2.2相关函数"></a>2.2相关函数</h3><p><strong>创建共享内存映射</strong>：</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
</code></pre>
<p>参数：</p>
<ul>
<li><p>addr：建立映射区的首地址，由Linux内核指定。使用时，写NULL即可。</p>
</li>
<li><p>length：要创建映射区的大小。</p>
</li>
<li><p>prot：映射区权限 <code>PORT_READ</code> 、<code>PORT_WRITE</code>、 <code>PORT_READ | PORT_WRITE</code>。</p>
</li>
<li><p>flags：标志位参数（常用于设定更新物理地址、设置共享、创建匿名映射区）。</p>
<p>​            <code>MAP_SHARED</code>：将映射区所做的操作反映到物理设备（磁盘）上。</p>
<p>​            <code>MAP_PRIVATE</code>：映射区所做的修改不会反映到物理设备上。</p>
</li>
<li><p>fd：用来建立映射区的文件描述符。</p>
</li>
<li><p>offset：映射文件的偏移（一定要是4k的整数倍）。</p>
</li>
</ul>
<p>返回值：成功返回创建的映射区首地址；失败返回<code>MAP_FAILED</code>宏。</p>
<p><strong>解除共享内存映射</strong>：</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/mman.h>
int munmap(void *addr, size_t length);
</code></pre>
<p>参数：</p>
<ul>
<li>addr：映射区的首地址。</li>
<li>length：映射区的大小。</li>
</ul>
<p>返回值：成功返回0；失败返回-1。</p>
<p><strong>一定要注意：</strong></p>
<ol>
<li>创建映射区的时候，隐含着一次对映射文件的读操作。</li>
<li>当<code>MAP_SHARED</code>时，要求：映射区的权限应 &lt;= 文件打开的权限（出于对映射区的保护）。而<code>MAP_PRIVATE</code>则无所谓，因为<code>mmap</code> 中的权限是对内存的限制。</li>
<li>映射区的释放和文件关闭无关。只要映射成功，文件可以立刻关闭。</li>
<li>特别注意：当映射文件大小为0时，不能创建映射区。所以：用于映射的文件必须要有实际的大小！！！<code>mmap</code>使用时常出现总线错误，通常是因为共享文件存储空间大小引起的。</li>
<li><code>munmap</code>传入的地址一定要是<code>mmap</code>返回的地址。坚决杜绝指针++操作。</li>
<li>如果文件偏移量必须为4k的整数倍。</li>
<li><code>mmap</code>创建的映射区出错概率非常高，一定要检查返回值，确保映射区建立成功后才进行后续操作。</li>
</ol>
<h3 id="2-3例子"><a href="#2-3例子" class="headerlink" title="2.3例子"></a>2.3例子</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <string.h>

#define MY_MMAP_SIZE 20
#define MY_MMAP_FILE "temp"

int main(void)
&#123;
    char *p = NULL;
    pid_t pid;

    int fd;
    fd = open(MY_MMAP_FILE, O_RDWR|O_CREAT|O_TRUNC, 0644);
    if(fd < 0)&#123;
        perror("open error");
        exit(1);
    &#125;
    unlink(MY_MMAP_FILE);        //删除临时文件目录项
    ftruncate(fd, MY_MMAP_SIZE);
    p = (char *)mmap(NULL, MY_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if(p == MAP_FAILED) &#123; // 注意，不是 p == NULL
        perror("mmap error");
    exit(1);
    &#125;
    close(fd);                   //映射区建立完毕,即可关闭文件

    pid = fork();                               //创建子进程
    if(pid == 0)&#123;
       char *data = "child hello!\n";
        strncpy(p, data, strlen(data) + 1);
       // *p = 1234;
        printf("son, *p = %s\n", p);
    &#125; else &#123;
        sleep(1);
        printf("parent, *p = %s\n", p);
        wait(NULL);

        int ret = munmap(p, MY_MMAP_SIZE);                 //释放映射区
        if (ret == -1) &#123;
            perror("munmap error");
            exit(1);
        &#125;
    &#125;

    return 0;
&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// 匿名映射方式，不要创建临时文件temp
// MAP_ANONYMOUS linux下才有此宏，类unix系统没有
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <string.h>

#define MY_MMAP_SIZE 20

int main(void)
&#123;
    char *p = NULL;
    pid_t pid;

    p = (char *)mmap(NULL, MY_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if(p == MAP_FAILED) &#123; // 注意，不是 p == NULL
        perror("mmap error");
    exit(1);
    &#125;

    pid = fork();                               //创建子进程
    if(pid == 0)&#123;
       char *data = "child hello!\n";
        strncpy(p, data, strlen(data) + 1);
       // *p = 1234;
        printf("son, *p = %s\n", p);
    &#125; else &#123;
        sleep(1);
        printf("parent, *p = %s\n", p);
        wait(NULL);

        int ret = munmap(p, MY_MMAP_SIZE);                 //释放映射区
        if (ret == -1) &#123;
            perror("munmap error");
            exit(1);
        &#125;
    &#125;

    return 0;
&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// 类unix系统的匿名映射方法，Linux也可以使用
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <string.h>

#define MY_MMAP_SIZE 20
#define MY_MMAP_FILE "/dev/zero"

int main(void)
&#123;
    char *p = NULL;
    pid_t pid;

    int fd;
    fd = open(MY_MMAP_FILE, O_RDWR);
    if(fd < 0)&#123;
        perror("open error");
        exit(1);
    &#125;

    p = (char *)mmap(NULL, MY_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if(p == MAP_FAILED) &#123; // 注意，不是 p == NULL
        perror("mmap error");
    exit(1);
    &#125;
    close(fd);                   //映射区建立完毕,即可关闭文件

    pid = fork();                               //创建子进程
    if(pid == 0)&#123;
       char *data = "child hello!\n";
        strncpy(p, data, strlen(data) + 1);
       // *p = 1234;
        printf("son, *p = %s\n", p);
    &#125; else &#123;
        sleep(1);
        printf("parent, *p = %s\n", p);
        wait(NULL);

        int ret = munmap(p, MY_MMAP_SIZE);                 //释放映射区
        if (ret == -1) &#123;
            perror("munmap error");
            exit(1);
        &#125;
    &#125;

    return 0;
&#125;
</code></pre>
<ul>
<li><code>/dev/zero</code>：在类UNIX 操作系统中, <code>/dev/zero</code> 是一个伪文件。<ul>
<li>产生连续不断的null的流 （二进制的零流，而不是ASCII型的）。</li>
<li>写入它的输出会丢失不见 。</li>
<li>主要的用处是用来创建一个指定长度用于初始化的空文件，像临时交换文件。</li>
<li>为特定的目的而用零去填充一个指定大小的文件，如挂载一个文件系统到环回设备 （<code>loopback device</code>） 或”安全地” 删除一个文件。</li>
</ul>
</li>
<li><code>/dev/null</code>：在类Unix系统中，<code>/dev/null</code>，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个<code>EOF</code>。<ul>
<li>被称为位桶(<code>bit bucket</code>)或者黑洞(<code>black hole</code>)。</li>
<li>通常被用于丢弃不需要的输出流，或作为用于输入流的空文件。这些操作通常由重定向完成。</li>
<li>等价于一个只写文件，并且所有写入它的内容都会永远丢失，而尝试从它那儿读取内容则什么也读不到。</li>
<li><code>cat $filename &gt;/dev/nul</code>l 则不会得到任何信息，因为我们将本来该通过标准输出显示的文件信息重定向到了 <code>/dev/null</code> 中。</li>
</ul>
</li>
</ul>
<pre class=" language-lang-c"><code class="language-lang-c">// mmap_wr.c
#include<stdio.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>
#include<sys/mman.h>


struct STU&#123;
    int id;
    char name[20];
    char sex;
&#125;;


void sys_err(char *str)
&#123;
    perror(str);
    exit(1);
&#125;

int main(int argc,char *argv[])
&#123;
    int fd;
    struct STU student = &#123;10, "xiaoming", 'm'&#125;;
    struct STU *mm;


    if(argc < 2)&#123;
        printf("./a.out file_shared\n");
        exit(-1);
    &#125;


    fd = open(argv[1],O_RDWR | O_CREAT, 0664);
    ftruncate(fd,sizeof(student));


    mm = mmap(NULL, sizeof(student), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if (mm == MAP_FAILED)
        sys_err("mmap error");


    close(fd);


    while (1) &#123;
        memcpy(mm, &student, sizeof(student));
        student.id++;
        sleep(1);
    &#125;


    munmap(mm, sizeof(student));
    return 0;
&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// mmap_rd.c
#include<stdio.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>
#include<sys/mman.h>


struct STU&#123;
    int id;
    char name[20];
    char sex;
&#125;;


void sys_err(char *str)
&#123;
    perror(str);
    exit(1);
&#125;


int main(int argc,char *argv[])
&#123;
    int fd;
    struct STU student;
    struct STU *mm;


    if(argc < 2)&#123;
        printf("./a.out file_shared\n");
        exit(-1);
    &#125;


    fd = open(argv[1],O_RDONLY);
    if (fd == -1)
    sys_err("open error");

    mm = mmap(NULL,sizeof(student),PROT_READ,MAP_SHARED,fd,0);
    if (mm == MAP_FAILED)
        sys_err("mmap error");


    close(fd);


    while (1) &#123;
        printf("id=%d\tname=%s\t%c\n", mm->id, mm->name, mm->sex);
        sleep(2);
    &#125;
    munmap(mm, sizeof(student));
    return 0;


&#125;
</code></pre>
<h2 id="3、套接字（socket）"><a href="#3、套接字（socket）" class="headerlink" title="3、套接字（socket）"></a>3、套接字（socket）</h2><h3 id="3-1基本概念"><a href="#3-1基本概念" class="headerlink" title="3.1基本概念"></a>3.1基本概念</h3><p><code>socket</code>套接字本身是为网络通信而设计的，但后来在<code>socket</code>的框架上发展出一种<code>IPC</code>机制，就是<code>Unix Domain Socket</code>。使用<code>Unix Domain Socket</code>的过程跟网络<code>socket</code>十分相似，也要先调用<code>socket()</code>创建一个<code>socket</code>文件描述符，<code>address_family</code>指定为<code>AF_UNIX</code>，<code>type</code>可以选择<code>SOCK_DGRAM</code>或者<code>SOCK_STREAM</code>，<code>protocol</code>参数仍然指定为0即可。</p>
<p><code>Unix Domain Socket</code>与网络<code>socket</code>编程的区别。</p>
<ul>
<li><p><code>Unix Domain Socket</code>：。</p>
<ul>
<li><p>地址格式结构体为<code>sockaddr_un</code>，<code>un</code>表示Unix。</p>
</li>
<li><p>地址是一个<code>socket</code>类型的文件在文件系统中的路径，这个<code>socket</code>文件由<code>bind()</code>调用创建，如果调用<code>bind()</code>时该文件已存在，则<code>bind()</code>错误返回。</p>
<pre class=" language-lang-c"><code class="language-lang-c">struct sockaddr_un &#123;
   __kernel_sa_family sun_family;   /* AF_UNIX */  地址结构类型
   char sun_path[UNIX_PATH_MAX];    /* pathname */ socket文件名（含路径）
&#125;;
</code></pre>
</li>
<li><p>将<code>Unix Domain socket</code>绑定到一个地址。</p>
<pre class=" language-lang-c"><code class="language-lang-c">size = offsetof(struct sockaddr_un, sunpath) + strlen(un.sun_path);
#define offsetof(type, member) ((int)&((type *)0)->MEMBER)
</code></pre>
</li>
</ul>
</li>
<li><p>网络<code>socket</code>编程：</p>
<ul>
<li><p>地址格式结构体为<code>sockaddr_in</code>，<code>in</code>表示Internet。</p>
</li>
<li><p>地址是IP地址加上端口号。</p>
<pre class=" language-lang-c"><code class="language-lang-c">struct sockaddr_in &#123;
    __kernel_sa_family_t sin_family; /* Address family */  地址结构类型
    __be16 sin_port;                 /* Port number */     端口号
    struct in_addr sin_addr;         /* Internet address */ip地址
&#125;;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="3-2例子"><a href="#3-2例子" class="headerlink" title="3.2例子"></a>3.2例子</h3><pre class=" language-lang-c"><code class="language-lang-c">// socket_server.c
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <string.h>
#include <strings.h>
#include <ctype.h>
#include <sys/un.h>
#include <stdlib.h>
#include "wrap.h"
#define SERVER_ADDR "server.socket"
#define SERVER_CONNECT_MAX 20

#define rdbuf_size 4096

int main(void)
&#123;
  int lfd, cfd, len, size;
  struct sockaddr_un serveraddr, clientaddr;
  char rdbuf[rdbuf_size] = &#123;0&#125;;

  lfd = Socket(AF_UNIX, SOCK_STREAM, 0);

  bzero(&serveraddr, sizeof(serveraddr));
  serveraddr.sun_family = AF_UNIX;
  strncpy(serveraddr.sun_path, SERVER_ADDR, sizeof(SERVER_ADDR));

  len = offsetof(struct sockaddr_un, sun_path) + strlen(serveraddr.sun_path); // serveraddr total len

  unlink(SERVER_ADDR);    // 确保bind之前 server.socket 文件不存在，bind() 会创建该文件
  Bind(lfd, (struct sockaddr *)&serveraddr, len); // 参3不能是 sizeof(serveraddr)

  Listen(lfd, SERVER_CONNECT_MAX);

  printf("Accept...\n");

  while(1)
  &#123;
    len = sizeof(clientaddr); // 好像不用这句也行
    cfd = Accept(lfd, (struct sockaddr *)&clientaddr, (socklen_t *)&len);

    len -= offsetof(struct sockaddr_un, sun_path); // 等到文件名的长度
    clientaddr.sun_path[len] = '\0'; // 确保打印时没有乱码

    printf("client bind filename %s \n", clientaddr.sun_path);

    while((size = read(cfd, rdbuf, rdbuf_size)) > 0)
    &#123;
      for(int i = 0; i < size; i++)
              rdbuf[i] = toupper(rdbuf[i]);
      int tmp = size;
      do &#123;
        int tmp2 = write(cfd, rdbuf, tmp);
        if(tmp2 == -1)
        &#123;
                perror("write error:");
                break;
        &#125;
        tmp -= tmp2; 
      &#125; while(tmp > 0);
    &#125;
    close(cfd);
  &#125;
  close(lfd);

  return 0;

&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// socket_client.c
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <string.h>
#include <strings.h>
#include <ctype.h>
#include <sys/un.h>
#include "wrap.h"

#define SERVER_ADDR "server.socket"
#define CLIENT_ADDR "client.socket"
#define FGETS_BUF_SIZE 4096


int main(void)
&#123;
  int cfd, len;
  struct sockaddr_un serveraddr, clientaddr;
  char buf[FGETS_BUF_SIZE] = &#123;0&#125;;

  cfd = Socket(AF_UNIX, SOCK_STREAM, 0);

  bzero(&clientaddr, sizeof(clientaddr));
  clientaddr.sun_family = AF_UNIX;
  strncpy(clientaddr.sun_path, CLIENT_ADDR, sizeof(CLIENT_ADDR));

  len = offsetof(struct sockaddr_un, sun_path) + strlen(clientaddr.sun_path); // 计算客户端地质结构有效长度

  unlink(CLIENT_ADDR);
  Bind(cfd, (struct sockaddr *)&clientaddr, len); // 客户端也需要bind，不能依赖自动绑定

  bzero(&serveraddr, sizeof(serveraddr));  // 构造server地址
  serveraddr.sun_family = AF_UNIX;
  strncpy(serveraddr.sun_path, SERVER_ADDR, sizeof(SERVER_ADDR));

  len = offsetof(struct sockaddr_un, sun_path) + strlen(serveraddr.sun_path); //计算服务器地址结构有效长度

  Connect(cfd, (struct sockaddr *)&serveraddr, len);

  while(fgets(buf, sizeof(buf), stdin) != NULL)
  &#123;
    write(cfd, buf, strlen(buf));
    len = read(cfd, buf, sizeof(buf));
    write(STDOUT_FILENO, buf, len);

  &#125;
  close(cfd);

&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// wrap.c 这里是socket的包裹函数
#include <stdio.h>
#include <wrap.h>
void err_sys(const char* x) 
&#123; 
    perror(x); 
    exit(1); 
&#125;

int Socket(int domain, int type, int protocol)
&#123;
  int n;
  if ((n = socket(domain, type, protocol)) < 0)
    err_sys("socket error");
  return (n);
&#125;

int Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
&#123;
  int n;
  if ((n = bind(sockfd, addr, addrlen)) < 0)
    err_sys("bind error");
  return (n);

&#125;

int Listen(int sockfd, int backlog)
&#123;
  int n;
  if ((n = listen(sockfd, backlog)) < 0)
    err_sys("listen error");
  return (n);

&#125;

int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
&#123;
  int n;
  if ((n = accept(sockfd, addr, addrlen)) < 0)
    err_sys("accept error");
  return (n);

&#125;

int Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
&#123;
  int n;
  if ((n = connect(sockfd, addr, addrlen)) < 0)
    err_sys("connect error");
  return (n);

&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// wrap.h
#ifndef __WRAP_H
#define __WRAP_H

#include <stdlib.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

#define offsetof(type, member) ((int)&((type *)0)->member)

int Socket(int domain, int type, int protocol);
int Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int Listen(int sockfd, int backlog);
int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
int Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

#endif
</code></pre>
<pre class=" language-lang-makefile"><code class="language-lang-makefile"># 这个makefile写不是很好，有待整改
all : socket_client socket_server
.PHONY : all

RM_TARGET = socket_client socket_server

CLIENT_OBJS = socket_client.o wrap.o
SERVER_OBJS = socket_server.o wrap.o

# LIBS := -lpthread
CFLAGS = -I. -g
CC = gcc
CXX = g++

socket_client : $(CLIENT_OBJS)
    $(CC) -o socket_client $(CLIENT_OBJS) $(CFLAGS) $(LIBS)

socket_server : $(SERVER_OBJS)
    $(CC) -o socket_server $(SERVER_OBJS) $(CFLAGS) $(LIBS)

$(CLIENT_OBJS) : %.o : %.c
    $(CC) -c $(CFLAGS) $< -o $@

$(SERVER_OBJS) : %.o : %.c
    $(CC) -c $(CFLAGS) $< -o $@

.PHONY : clean
clean :
    -$(RM) socket_server socket_client  $(CLIENT_OBJS) $(SERVER_OBJS)
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下线程的使用</title>
    <url>/2021/06/25/linuxPthread/</url>
    <content><![CDATA[<h1 id="Linux下线程的使用"><a href="#Linux下线程的使用" class="headerlink" title="Linux下线程的使用"></a>Linux下线程的使用</h1><h2 id="1、Linux线程"><a href="#1、Linux线程" class="headerlink" title="1、Linux线程"></a>1、Linux线程</h2><ul>
<li><p>在早期的类Unix系统中是没有“线程”概念的，这是后面需求的才延伸出来的，它借助了进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。在Linux环境下的线程本质上还是进程，属于轻量级的进程（LWP：light weight process）。</p>
</li>
<li><p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。</p>
</li>
<li>fork复制对方的地址空间，产生一个“进程”；pthread_create共享对方的地址空间，就产生一个“线程”。</li>
</ul>
<h2 id="2、Linux线程创建"><a href="#2、Linux线程创建" class="headerlink" title="2、Linux线程创建"></a>2、Linux线程创建</h2><blockquote>
<p>使用下面所有的线程相关函数都必须做的工作：</p>
<p>1、包含头文件  #include <pthread.h></p>
<p>2、编译时链接线程库(线程库的名字叫pthread, 全名: libpthread.so libptread.a) -pthread</p>
</blockquote>
<h3 id="2-1获取线程ID（对应进程中-getpid-函数）"><a href="#2-1获取线程ID（对应进程中-getpid-函数）" class="headerlink" title="2.1获取线程ID（对应进程中 getpid() 函数）"></a>2.1获取线程ID（对应进程中 getpid() 函数）</h3><p>每一个线程都对应一个唯一的线程 ID（两个进程间，线程ID允许相同），ID 类型为 pthread_t，这个 ID 是一个无符号长整形数(%lu)，如果想要获取当前线程的线程 ID，可以调用如下函数：</p>
<pre class=" language-lang-c"><code class="language-lang-c">pthread_t pthread_self(void);    // 返回当前线程的线程ID，man说这个函数总会执行成功
</code></pre>
<h3 id="2-2创建线程函数（对应进程中fork-函数）"><a href="#2-2创建线程函数（对应进程中fork-函数）" class="headerlink" title="2.2创建线程函数（对应进程中fork() 函数）"></a>2.2创建线程函数（对应进程中fork() 函数）</h3><pre class=" language-lang-c"><code class="language-lang-c">int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
</code></pre>
<ul>
<li><p>参数：</p>
<ul>
<li>thread：传出参数，创建成功时保存系统为我们分配好的线程ID。</li>
<li>attr：通常传NULL，表示使用线程默认属性。也可自行修改。</li>
<li>start_routine：函数指针，指向线程任务函数(线程体)，该函数运行结束，则线程结束。该函数在子线程中执行。</li>
<li>arg：通过它把需要传递的参数传递到start_routine指向的函数体内部，如要传多个参数, 可以用结构封装。</li>
</ul>
</li>
<li><p>返回值：成功返回0； 失败返回错误号。具体错误可通过strerror()函数输出。</p>
</li>
</ul>
<h3 id="2-3实例"><a href="#2-3实例" class="headerlink" title="2.3实例"></a>2.3实例</h3><pre class=" language-lang-c"><code class="language-lang-c">// my_pthread_create.c 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

struct Test
&#123;
    int num;
    int age;
&#125;;
void * mytask(void * arg)
&#123;
    for (int i = 0; i < 5; i++)
    &#123;
        printf("子线程：i = %d\n", i);
    &#125;
    printf("子线程TID：%ld\n", pthread_self());

    struct Test * pt = (struct Test *)arg;
    pt->num = 1000;
    pt->age = 99;

    return NULL;
&#125;
int main()
&#123;
    pthread_t tid;
    struct Test test;

    pthread_create(&tid, NULL, mytask, &test);
    printf("子线程创建成功, 线程TID: %ld\n", tid);
    printf("主线程TID：%ld\n", pthread_self());

    return 0;
&#125;
</code></pre>
<p>执行命令编译程序，<code>-lpthread</code>的意思是链接<code>pthread</code>线程库，要用线程相关函数除了包含头文件<code>#include &lt;pthread.h&gt;</code>以外，编译的时候还得指定链接线程库，否则编译失败。<code>-o app</code>的意思是指定输出的可执行文件名为<code>app</code>。</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">gcc my_pthread_create.c -lpthread -o app
</code></pre>
<pre class=" language-lang-shell"><code class="language-lang-shell">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# gcc my_pthread_create.c -lpthread -o app
root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ls
app  my_pthread_create.c
root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ./app 
子线程创建成功, 线程TID: 139769949230848
主线程TID：139769949235008
root@iZwz94euuu9omhoocm3l5uZ:~/07_article#
</code></pre>
<p>编译执行后发现子线程虽然创建成功，但是子线程任务函数里面的打印并没有输出，原因是：</p>
<p>主线程一直在运行，执行期间创建出了子线程，接下来主线程和子线程“并发”，分道扬镳，各自执行自己的函数。子线程刚被创建出来，需要去抢CPU时间片，抢到了CPU时间片子线程的任务函数才能运行。</p>
<p>很明显，此时此刻，子线程并没有抢到CPU时间片，而主线程却抢到了。然后主线程去执行printf，执行完后发现没有工作要做了就直接返回退出了。</p>
<p>但主线程退出了, 虚拟地址空间就被释放了, 子线程就一并被销毁了，这样子线程任务函数里的printf就肯定没法运行了。</p>
<h2 id="3、Linux线程退出"><a href="#3、Linux线程退出" class="headerlink" title="3、Linux线程退出"></a>3、Linux线程退出</h2><p>在多线程进程中，要让主线程退出不导致虚拟地址空间的释放，剩下的子线程继续正常运行，可以在主线程中调用线程退出函数。线程退出函数会让当前线程马上退出，而且不会释放虚拟地址空间，不会影响到其他线程的正常运行。线程退出函数可以在子线程或者主线程中都使用。</p>
<h3 id="3-1线程退出函数"><a href="#3-1线程退出函数" class="headerlink" title="3.1线程退出函数"></a>3.1线程退出函数</h3><pre class=" language-lang-c"><code class="language-lang-c">void pthread_exit(void *retval);
</code></pre>
<ul>
<li>参数：线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为 NULL。一般使用的这个线程退出带出数据的功能的时候，需要在线程创建的时候把一块堆内存的指针传进去。</li>
</ul>
<h3 id="3-2实例"><a href="#3-2实例" class="headerlink" title="3.2实例"></a>3.2实例</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

struct Test
&#123;
    int num;
    int age;
&#125;;
void * mytask(void * arg)
&#123;
    for (int i = 0; i < 10; i++)
    &#123;
        printf("子线程：i = %d\n", i);
        if(i == 7)
        &#123;
            pthread_exit(NULL); // 直接退出子线程
        &#125;
    &#125;
    printf("子线程TID：%ld\n", pthread_self());

    struct Test * pt = (struct Test *)arg;
    pt->num = 1000;
    pt->age = 99;

    return NULL;
&#125;
int main()
&#123;
    pthread_t tid;
    struct Test test;

    pthread_create(&tid, NULL, mytask, &test);
    printf("子线程创建成功, 线程TID: %ld\n", tid);
    printf("主线程TID：%ld\n", pthread_self());

    pthread_exit(NULL); // 主线程退出，不会释放虚拟地址空间，不影响子线程运行
    return 0;
&#125;
</code></pre>
<p>编译执行结果：</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# gcc my_pthread_create.c -lpthread -o app
root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ./app 
子线程创建成功, 线程TID: 139901666547456
主线程TID：139901666551616
子线程：i = 0
子线程：i = 1
子线程：i = 2
子线程：i = 3
子线程：i = 4
子线程：i = 5
子线程：i = 6
子线程：i = 7
root@iZwz94euuu9omhoocm3l5uZ:~/07_article#
</code></pre>
<p>上面的程序执行结果说明，主线程执行<code>printf</code>就先退出了，此时虚拟地址空间还没有被释放，子线程继续执行<code>printf</code>，直到子线程执行到<code>pthread_exit</code>子线程就退出了，然后虚拟地址空间被释放，进程退出。</p>
<h2 id="4、Linux线程回收"><a href="#4、Linux线程回收" class="headerlink" title="4、Linux线程回收"></a>4、Linux线程回收</h2><p>子线程在一般情况下都是由主线程创建并启动的，如果子线程相对主线程而言要进行大量的耗时的运算，那么主线程就会先于子线程结束，就好比如<code>3.2实例</code>。但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束线程和进程，这种情况该怎么处理呢？</p>
<p>这就是线程回收函数 <code>pthread_join</code>的应用场景了，这个函数是一个阻塞函数，如果子线程还在运行，该函数就会一直阻塞，子线程退出函数解除阻塞进行资源的回收。函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p>
<h3 id="4-1线程回收函数（对应进程中-waitpid-函数）"><a href="#4-1线程回收函数（对应进程中-waitpid-函数）" class="headerlink" title="4.1线程回收函数（对应进程中 waitpid() 函数）"></a>4.1线程回收函数（对应进程中 waitpid() 函数）</h3><pre class=" language-lang-c"><code class="language-lang-c">// 这是一个阻塞函数, 由主线程调用，然后就阻塞在这，直到thread子线程退出，然后返回。
// 回收对应的子线程资源
int pthread_join(pthread_t thread, void **retval);
</code></pre>
<ul>
<li>参数：<ul>
<li>thread：要被回收的子线程的线程 ID</li>
<li>retval：被回收的子线程通过它传出 <code>pthread_exit</code>的参数，即要传出的数据。</li>
</ul>
</li>
</ul>
<h3 id="4-2实例"><a href="#4-2实例" class="headerlink" title="4.2实例"></a>4.2实例</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

struct Test
&#123;
    int num;
    int age;
&#125;;
void * mytask(void * arg)
&#123;
    struct Test * pt = (struct Test *)arg;
    pt->num = 1000;
    pt->age = 99;
    for (int i = 0; i < 10; i++)
    &#123;
        printf("子线程：i = %d\n", i);
        if(i == 7)
        &#123;
            pthread_exit(pt); // 直接退出子线程
        &#125;
    &#125;
    printf("子线程TID：%ld\n", pthread_self());

    return NULL;
&#125;
int main()
&#123;
    pthread_t tid;
    struct Test test;

    // 子线程用到了主线程的栈空间test，所以主线程必须等子线程退出后再退出
    pthread_create(&tid, NULL, mytask, &test);
    printf("子线程创建成功, 线程TID: %ld\n", tid);
    printf("主线程TID：%ld\n", pthread_self());

    void* ptr = NULL;
    // ptr是一个传出参数, 子线程回收资源被存放在此
    // 这个内存地址就是pthread_exit() 参数指向的内存
    // 阻塞等待子线程退出
    pthread_join(tid, &ptr);

    struct Test* tmp = (struct Test*)ptr;
    printf("子线程返回数据: age: %d, num: %d\n", tmp->age, tmp->num);
    printf("子线程资源被成功回收...\n");

    return 0;
&#125;
</code></pre>
<p>编译执行结果：</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# gcc my_pthread_create.c -lpthread -o app
root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ./app 
子线程创建成功, 线程TID: 140123287721728
主线程TID：140123287725888
子线程：i = 0
子线程：i = 1
子线程：i = 2
子线程：i = 3
子线程：i = 4
子线程：i = 5
子线程：i = 6
子线程：i = 7
子线程返回数据: age: 99, num: 1000
子线程资源被成功回收...
root@iZwz94euuu9omhoocm3l5uZ:~/07_article#
</code></pre>
<p>注意：虽然每个线程都有属于自己的栈区空间，但是位于同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的。当然，线程创建函数<code>pthread_create</code>的参数<code>arg</code>也可以是全局变量或者堆存的内存。</p>
<h2 id="5、Linux线程分离"><a href="#5、Linux线程分离" class="headerlink" title="5、Linux线程分离"></a>5、Linux线程分离</h2><p>有时候，进程中的主线程也有自己的业务处理流程，如果还是让主线程负责子线程的资源回收，调用 <code>pthread_join</code>后，只要子线程不退出主线程就会一直被阻塞，主线程就没办法执行自己的业务处理流程了。</p>
<p>这就是线程分离函数<code>pthread_detach</code>的应用场景了，调用线程分离函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源会被系统的其他进程接管并回收了。线程分离之后在主线程中使用 <code>pthread_join</code>是回收不到子线程资源了的。</p>
<h3 id="5-1线程分离函数"><a href="#5-1线程分离函数" class="headerlink" title="5.1线程分离函数"></a>5.1线程分离函数</h3><pre class=" language-lang-c"><code class="language-lang-c">int pthread_detach(pthread_t thread);
</code></pre>
<ul>
<li><p>参数：</p>
<ul>
<li>thread：要与主线程分离的子线程的线程ID。</li>
</ul>
</li>
<li><p>返回值：成功返回0，失败返回错误码。</p>
</li>
</ul>
<h3 id="5-2实例"><a href="#5-2实例" class="headerlink" title="5.2实例"></a>5.2实例</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

void * mytask(void * arg)
&#123;

    for (int i = 0; i < 10; i++)
    &#123;
        printf("子线程：i = %d\n", i);

    &#125;
    printf("子线程TID：%ld\n", pthread_self());

    return NULL;
&#125;
int main()
&#123;
    pthread_t tid;

    pthread_create(&tid, NULL, mytask, NULL);
    printf("子线程创建成功, 线程TID: %ld\n", tid);
    printf("主线程TID：%ld\n", pthread_self());

    // 主线程子线程分离
    pthread_detach(tid);

    // 主线程你自己先退出吧，不用管我，我一个“人”很好
    pthread_exit(NULL);

    return 0;
&#125;
</code></pre>
<p>程序编译运行结果：</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">root@iZwz94euuu9omhoocm3l5uZ:~/07_article# gcc my_pthread_create.c -lpthread -o app
root@iZwz94euuu9omhoocm3l5uZ:~/07_article# ./app 
子线程创建成功, 线程TID: 139791846512384
主线程TID：139791846516544
子线程：i = 0
子线程：i = 1
子线程：i = 2
子线程：i = 3
子线程：i = 4
子线程：i = 5
子线程：i = 6
子线程：i = 7
子线程：i = 8
子线程：i = 9
子线程TID：139791846512384
root@iZwz94euuu9omhoocm3l5uZ:~/07_article#
</code></pre>
<h2 id="6、Linux其它线程函数"><a href="#6、Linux其它线程函数" class="headerlink" title="6、Linux其它线程函数"></a>6、Linux其它线程函数</h2><h3 id="6-1线程取消函数（对应进程中-kill-函数）"><a href="#6-1线程取消函数（对应进程中-kill-函数）" class="headerlink" title="6.1线程取消函数（对应进程中 kill() 函数）"></a>6.1线程取消函数（对应进程中 kill() 函数）</h3><p>杀死（取消）线程 其作用。但不会立刻杀死（取消）进程，只有当<code>thread</code>进行了一次系统调用（从用户区切换到内核区），才会死掉。</p>
<pre class=" language-lang-c"><code class="language-lang-c">int pthread_cancel(pthread_t thread);
</code></pre>
<ul>
<li><p>参数：</p>
<ul>
<li>thread：要杀死（取消）线程的线程ID。</li>
</ul>
</li>
<li><p>返回值：成功返回0，失败返回错误码。</p>
</li>
</ul>
<h3 id="6-2线程ID是否相同函数"><a href="#6-2线程ID是否相同函数" class="headerlink" title="6.2线程ID是否相同函数"></a>6.2线程ID是否相同函数</h3><pre class=" language-lang-c"><code class="language-lang-c">int pthread_equal(pthread_t t1, pthread_t t2);
</code></pre>
<ul>
<li><p>参数：两个要比较的线程ID。</p>
</li>
<li><p>返回值：两个线程 ID 相等返回非 0 值，如果不相等返回 0。</p>
</li>
</ul>
<h2 id="7、埋个坑"><a href="#7、埋个坑" class="headerlink" title="7、埋个坑"></a>7、埋个坑</h2><ol>
<li>多线程的同步与互斥使用</li>
<li>线程池</li>
<li>高并发</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>线程进程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>线程进程</tag>
      </tags>
  </entry>
  <entry>
    <title>基本的Makefile使用</title>
    <url>/2021/07/07/makefile-simple/</url>
    <content><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>makefile是一个代码管理工具，它定义了一系列的规则来指定那些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译。</p>
<p>最大的好处就是，只要把makefile写好，然后执行一个make命令就完成所有的编译了。</p>
<p>不然每次编译都要敲一大串命令，很容易把我们累死。例如：</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">gcc *.c -Include ./ -Wall -g -O3 -D DEBUG -L
</code></pre>
<h2 id="makefile的命名"><a href="#makefile的命名" class="headerlink" title="makefile的命名"></a>makefile的命名</h2><p>makefile命名只有两种情况，任选其一即可：makefile、Makefile。</p>
<h2 id="makefile的规则"><a href="#makefile的规则" class="headerlink" title="makefile的规则"></a>makefile的规则</h2><p>规则中的三要素：目标，依赖，规则。一条规则的形式如下：</p>
<blockquote>
<p>目标：依赖条件</p>
<p>​    命令</p>
</blockquote>
<p>注意命令前面必须是一个Table缩进。</p>
<p>如果makefile中有多条规则，则默认第一条规则中的目标是我们的终极目标。makefile向下检索，构建出一颗关系树，从下往上执行命令。</p>
<p>make命令生成的目标都是终极目标。</p>
<p><img src="https://i.loli.net/2021/07/07/5IrjAsQVm8TaPDC.png" alt="makefile工作原理.png"></p>
<p>例子：</p>
<pre class=" language-lang-makefile"><code class="language-lang-makefile">main:main.c sub.c add.c
    gcc main.c sub.c add.c -o main
</code></pre>
<p>可见，目标就是我们想要生成的文件，依赖就是我们的源文件，命令就是我们用依赖生成目标的命令，例如这里的就是gcc编译的命令。</p>
<p>上面例子是makefile和main.c 、sub.c、add.c是处于同一目录下的，如果不处于同一目录，需要显示指出源文件的目录。</p>
<h2 id="makefile的分文件编译"><a href="#makefile的分文件编译" class="headerlink" title="makefile的分文件编译"></a>makefile的分文件编译</h2><p>当一个项目的源文件很多很多时，需要对文件的进行分文件编译，否则修改了其中一个源文件，就会导致整个项目的源文件都重新编译了一次，浪费时间。</p>
<pre class=" language-lang-makefile"><code class="language-lang-makefile">main:main.o sub.o add.o
    gcc main.o sub.o add.o

main.o:main.c
    gcc -c main.c

sub.o:sub.c
    gcc -c sub.c

add.o:add.c
    gcc -c add.c
</code></pre>
<h2 id="makefile的变量"><a href="#makefile的变量" class="headerlink" title="makefile的变量"></a>makefile的变量</h2><p>makefile定义变量不需要数据类型，直接定义即可，但要取变量里的内容则需在其前加<code>$</code>符号，一般也会将变量用<code>()</code>括起来。</p>
<pre class=" language-lang-makefile"><code class="language-lang-makefile">obj = main.o sub.o add.o
target = main

$(target):$(obj)
    gcc $(obj) -o $(target)

main.o:main.c
    gcc -c main.c

sub.o:sub.c
    gcc -c sub.c

add.o:add.c
    gcc -c add.c
</code></pre>
<h2 id="makefile的自动变量"><a href="#makefile的自动变量" class="headerlink" title="makefile的自动变量"></a>makefile的自动变量</h2><p>%&lt;：规则中的第一个依赖</p>
<p>%@：规则中的目标</p>
<p>%^：规则中的所有依赖</p>
<p><strong>只能在规则中的命令使用。</strong></p>
<h2 id="makefile的“-”"><a href="#makefile的“-”" class="headerlink" title="makefile的“=”"></a>makefile的“=”</h2><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>最基本的赋值</td>
</tr>
<tr>
<td>:=</td>
<td>覆盖之前的值</td>
</tr>
<tr>
<td>?=</td>
<td>如果没有被赋值过就赋予等号后面的值</td>
</tr>
<tr>
<td>+=</td>
<td>添加等号后面的值</td>
</tr>
</tbody>
</table>
</div>
<h2 id="makefile的模式规则"><a href="#makefile的模式规则" class="headerlink" title="makefile的模式规则"></a>makefile的模式规则</h2><p>在规则的目标定义使用%，在规则的依赖条件使用%。</p>
<pre class=" language-lang-makefile"><code class="language-lang-makefile">obj = main.o sub.o add.o
target = main

$(target):$(obj)
    gcc $(obj) -o $(target)

%.o:%.c
    gcc -c $< -o $@
</code></pre>
<p>%.o:%.c 相当于 main.o:main.c、sub.0:sub.c、add.o:add.c。模式规则会帮我们自动匹配上。</p>
<h2 id="makefile自己维护的变量"><a href="#makefile自己维护的变量" class="headerlink" title="makefile自己维护的变量"></a>makefile自己维护的变量</h2><p>特征：通常变量名全大写</p>
<p>CC：默认值为cc，cc其实也就是gcc。</p>
<p>CPPFLAGS：预处理的时候使用的参数。例如：</p>
<p><code>CPPFLAGS = -I</code>预处理的时候指定头文件路径。</p>
<p>CFLAGS：编译的时候使用的参数。例如：</p>
<p><code>CFLAGS = -Wall -g -c</code>编译的时候显示警告、加入调试信息、只编译</p>
<p>LDFLAGS：链接库的时候使用的选项。</p>
<p><code>LDFLAGS = -L -l</code>链接库的时候指定库路径、库名。</p>
<pre class=" language-lang-makefile"><code class="language-lang-makefile">obj = main.o sub.o add.o
target = main
CC = gcc
CPPFLAGS = -I
$(target):$(obj)
    $(CC) $(obj) -o $(target)

%.o:%.c
    $(CC) -c $< -o $@
</code></pre>
<h2 id="makefile的函数"><a href="#makefile的函数" class="headerlink" title="makefile的函数"></a>makefile的函数</h2><p>makefile中使用的所有函数都是有返回值的，函数名与参数通过空格分开，参数与参数之间通过逗号分开。</p>
<p>$(wildcard <pattern>…)</p>
<p>$(patsubst <pattern>,<replacement>,<text>)</p>
<p>一般这两个函数结合使用。wildcard 通过通配符找到相关的.c源文件，返回它们的字符串，再通过 patsubst 模式替换将.c源文件的名称的字符串替换成对应的.o目标文件。</p>
<pre class=" language-lang-makefile"><code class="language-lang-makefile">target = main
src = $(wildcard ./*.c)
obj = $(patsubst ./%.c, ./%.o, $(src))
CC = gcc
CPPFLAGS = -I
$(target):$(obj)
    $(CC) $(obj) -o $(target)

%.o:%.c
    $(CC) -c $< -o $@
</code></pre>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><p>伪目标，没有依赖。用于删除所有被 make 创建的文件。</p>
<pre class=" language-lang-makefile"><code class="language-lang-makefile">target = main
src = $(wildcard ./*.c)
obj = $(patsubst ./%.c, ./%.o, $(src))
CC = gcc
CPPFLAGS = -I
$(target):$(obj)
    $(CC) $(obj) -o $(target)

%.o:%.c
    $(CC) -c $< -o $@

.PHONY:clean
clean:
    -rm $(target) $(obj) -f
</code></pre>
<p>-：如果出错，忽略当前命令，继续向下执行下面的命令。</p>
<p>-f：强制执行，不管有没有对应的文件都删除。</p>
<p>.PHONY:clean：声明clean为伪目标。</p>
]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程、线程并发服务器</title>
    <url>/2021/07/05/multi-proc-pthread-server/</url>
    <content><![CDATA[<h1 id="多进程、线程并发服务器"><a href="#多进程、线程并发服务器" class="headerlink" title="多进程、线程并发服务器"></a>多进程、线程并发服务器</h1><h2 id="多进程并发服务器"><a href="#多进程并发服务器" class="headerlink" title="多进程并发服务器"></a>多进程并发服务器</h2><h3 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <ctype.h>
#include <strings.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

#include "wrap.h"
#define SERV_PORT 8888

void wait_chld(int signo)
&#123;
  while(waitpid(0, NULL, WNOHANG) > 0); // 0：回收属于同一进程组的所有子进程， WNOHANG：不阻塞
  return;
&#125;

int main(void)
&#123;
        pid_t pid;
        int i, n;
        int lfd, cfd;
        struct sockaddr_in serv_addr, clie_addr;
        socklen_t clie_addr_len;
        char buf[1024] = &#123;0&#125;;
        char clientip[1024] = &#123;0&#125;;
        lfd = Socket(AF_INET, SOCK_STREAM, 0);

        bzero(&serv_addr, sizeof(serv_addr));

        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port = htons(SERV_PORT);
        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
        //inet_pton(AF_INET, "192.168.10.100", &serv_addr.sin_addr.s_addr);
        Bind(lfd, (const struct sockaddr *)&serv_addr, (socklen_t)sizeof(serv_addr));

        Listen(lfd, 128); // 操作系统运行最大监听数为128

        while(1)
        &#123;
                clie_addr_len = sizeof(clie_addr);
                cfd = Accept(lfd, (struct sockaddr *)&clie_addr, &clie_addr_len);
                printf("client ip:%s, port:%d\n", inet_ntop(AF_INET, &clie_addr.sin_addr.s_addr, clientip, sizeof(clientip)),
                                ntohs(clie_addr.sin_port));

                pid = fork();
                if(pid < 0)
                &#123;
                        perror("fork error");
                        exit(1);
                &#125;
                else if(pid == 0)
                &#123;
                        close(lfd);
                        break;
                &#125;
                else
                &#123;
                        close(cfd);
                        signal(SIGCHLD, wait_chld);
                &#125;
        &#125;

        if(pid == 0)
        &#123;
                while(1)
                &#123;
                        n = Read(cfd, buf, sizeof(buf));
                        if(n == 0) // 0表示对方连接断开
                        &#123;
                                close(cfd);
                                return 0;
                        &#125;
                        else if(n == -1)
                        &#123;
                                perror("read error");
                                exit(1);
                        &#125;
                        else
                        &#123;
                                for(i = 0; i < n; i++)
                                &#123;
                                        buf[i] = toupper(buf[i]);
                                &#125;
                                write(cfd, buf, n);
                                write(STDOUT_FILENO, buf, n);
                        &#125;
                &#125;
        &#125;
        return 0;
&#125;
</code></pre>
<h3 id="wrap-c"><a href="#wrap-c" class="headerlink" title="wrap.c"></a>wrap.c</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <wrap.h>
#include <unistd.h>
#include <errno.h>
void err_sys(const char* x)
&#123;
    perror(x);
    exit(1);
&#125;

int Socket(int domain, int type, int protocol)
&#123;
  int n;
  if ((n = socket(domain, type, protocol)) < 0)
    err_sys("socket error");
  return (n);
&#125;

int Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
&#123;
  int n;
  if ((n = bind(sockfd, addr, addrlen)) < 0)
    err_sys("bind error");
  return (n);

&#125;

int Listen(int sockfd, int backlog)
&#123;
  int n;
  if ((n = listen(sockfd, backlog)) < 0)
    err_sys("listen error");
  return (n);

&#125;

int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
&#123;
  int n;

  do &#123;

    if ((n = accept(sockfd, addr, addrlen)) < 0)
    &#123;
      if((errno == ECONNABORTED) || (errno == EINTR))
      &#123;

      &#125;
      else
      &#123;
        err_sys("accept error");
        break;
      &#125;
    &#125;
  &#125; while(n < 0);
  return (n);

&#125;

int Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
&#123;
  int n;
  if ((n = connect(sockfd, addr, addrlen)) < 0)
    err_sys("connect error");
  return (n);

&#125;

ssize_t Read(int fd, void *buf, size_t count)
&#123;
  ssize_t n;

again:
  if((n = read(fd, buf, count)) == -1)
  &#123;
    if(errno == EINTR)
    &#123;
      goto again;
    &#125;
    return -1;
  &#125;

  return n;
&#125;

ssize_t Write(int fd, const void *buf, size_t count)
&#123;
  ssize_t n;

  do &#123;
    if((n = write(fd, buf, count)) == -1)
    &#123;
      if(errno != EINTR)
      &#123;
        return -1;
      &#125;
    &#125;
  &#125; while(n != -1);

  return n;
&#125;

int Close(int fd)
&#123;
  int n;
  if((n = close(fd)) == -1)
      err_sys("connect error");
  return n;
&#125;

ssize_t Readn(int fd, void *vptr, ssize_t n)
&#123;
  size_t nleft;   // unsigned int 剩余未读取的字节数
  ssize_t nread;  // int 实际读到的字节数

  const char *ptr = vptr;
  nleft = n;      // n 未读取的字节数


  while(nleft > 0)
  &#123;
    if((nread = read(fd, (void *)ptr, nleft)) < 0)
    &#123;
      if(errno == EINTR)
        nread = 0;
      else
        return -1;
    &#125;
    else if(nread == 0)
      break;

    nleft -= nread;
    ptr += nread;
  &#125;

  return n - nleft;
&#125;

ssize_t Writen(int fd, const void *vptr, size_t n)
&#123;
  size_t nleft;   // unsigned int 剩余未写出的字节数
  ssize_t nwriten;  // int 实际写出的字节数

  const char *ptr = vptr;
  nleft = n;      // n 未写出的字节数


  while(nleft > 0)
  &#123;
    if((nwriten = write(fd, ptr, nleft)) <= 0)
    &#123;
      if(errno == EINTR && nwriten < 0)
        nwriten = 0;
      else
        return -1;
    &#125;
    else if(nwriten == 0)
      break;

    nleft -= nwriten;
    ptr += nwriten;
  &#125;

  return n - nleft;

&#125;
</code></pre>
<h3 id="wrap-h"><a href="#wrap-h" class="headerlink" title="wrap.h"></a>wrap.h</h3><pre class=" language-lang-c"><code class="language-lang-c">#ifndef __WRAP_H
#define __WRAP_H

#include <stdlib.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

#define offsetof(type, member) ((int)&((type *)0)->member)

int Socket(int domain, int type, int protocol);
int Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int Listen(int sockfd, int backlog);
int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
int Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
ssize_t Read(int fd, void *buf, size_t count);
ssize_t Write(int fd, const void *buf, size_t count);
int Close(int fd);
ssize_t Readn(int fd, void *vptr, ssize_t n);
ssize_t Writen(int fd, const void *vptr, size_t n);

#endif
</code></pre>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><pre class=" language-lang-makefile"><code class="language-lang-makefile">all : server
.PHONY : all

src = $(wildcard ./*.c) # wildcard函数：显示指定路径下指定文件类型的所有文件
obj = $(patsubst ./%.c, ./%.o, $(src)) # patsubst函数：.c 替换成 .o

# LIBS := -lpthread
CFLAGS = -I. -g -Wall
CC = gcc
CXX = g++

server : $(obj)
        $(CC) -o server $(obj) $(CFLAGS) $(LIBS)

# $@  表示目标文件
# $<  表示第一个依赖文件
%.o : %.c
        $(CC) -c $(CFLAGS) $< -o $@


# -  即使出错也继续执行后面
.PHONY : clean  # .PHONY 伪目标，有了这句，不管怎样都执行clean
clean :
        -$(RM) server  $(obj)
</code></pre>
<h2 id="多线程并发服务器"><a href="#多线程并发服务器" class="headerlink" title="多线程并发服务器"></a>多线程并发服务器</h2><h3 id="server-c-1"><a href="#server-c-1" class="headerlink" title="server.c"></a>server.c</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <fcntl.h>
#include "wrap.h"

#define MAXSIZE 8192
#define SERV_PORT 8888
// 定义i一个结构体，将结构体跟cfd捆绑
struct s_info&#123;
  struct sockaddr_in clieaddr;
  int connfd;
&#125;;


void *dowork(void * arg)
&#123;
  int n, i;
  struct s_info *ts = (struct s_info *)arg;
  char buf[MAXSIZE] = &#123;0&#125;;
  char str[INET_ADDRSTRLEN]; // #define INET_ADDRSRTLEN 16 可用"[+d"查看

  while(1)
  &#123;
    n = Read(ts->connfd, buf, MAXSIZE);   // 读客户端
    if(n == 0)
    &#123;
      printf("the client %d closed...\n", ts->connfd);
      break; // 对端关闭连接
    &#125;
    printf("reaeived from %s at port %d",
                    inet_ntop(AF_INET, &ts->clieaddr.sin_addr.s_addr, str, sizeof(str)),
                    ntohs(ts->clieaddr.sin_port)); // 打印客户端信息

    for(i = 0; i < n; i++)
    &#123;
      buf[i] = toupper(buf[i]);
    &#125;

    Write(STDOUT_FILENO, buf, n); // 打印到屏幕
    Write(ts->connfd, buf, n);  // 回显给客户端

  &#125;
  Close(ts->connfd);
  return (void *)0;
&#125;

int main(void)
&#123;
        int i;
        int lfd, cfd;
        struct sockaddr_in serv_addr, clie_addr;
        socklen_t clie_addr_len;
        pthread_t tid;
        struct s_info ts[256]; // 根据最大线程数创建结数组
        char clientip[256];

        lfd = Socket(AF_INET, SOCK_STREAM, 0);

        bzero(&serv_addr, sizeof(serv_addr));

        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port = htons(SERV_PORT);
        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  // 指定本地任意IP
        //inet_pton(AF_INET, "192.168.10.100", &serv_addr.sin_addr.s_addr);
        Bind(lfd, (const struct sockaddr *)&serv_addr, (socklen_t)sizeof(serv_addr));

        Listen(lfd, 128); // 设置同一时刻连接服务器的上限，操作系统运行最大监听数为128

        printf("Accepting client connect ...\n");
        while(1)
        &#123;
                clie_addr_len = sizeof(clie_addr);
                cfd = Accept(lfd, (struct sockaddr *)&clie_addr, &clie_addr_len); // 阻塞监听客户端连接请求
                printf("client ip:%s, port:%d\n", inet_ntop(AF_INET, &clie_addr.sin_addr.s_addr, clientip, sizeof(clientip)),
                                ntohs(clie_addr.sin_port));
                ts[i].clieaddr = clie_addr;
                ts[i].connfd = cfd;

                /* 达到最大线程数时，pthread_create出错处理，增加系统服务稳定性*/
                pthread_create(&tid, NULL, dowork, (void *)&ts[i]);
                pthread_detach(tid); // 子线程分离，防止僵尸线程产生
                i++;
        &#125;
        return 0;
&#125;
</code></pre>
<h3 id="wrap-c-1"><a href="#wrap-c-1" class="headerlink" title="wrap.c"></a>wrap.c</h3><p>跟前面多进程版一致</p>
<h3 id="wrap-h-1"><a href="#wrap-h-1" class="headerlink" title="wrap.h"></a>wrap.h</h3><p>跟前面多进程版一致</p>
<h3 id="Makefile-1"><a href="#Makefile-1" class="headerlink" title="Makefile"></a>Makefile</h3><pre class=" language-lang-makefile"><code class="language-lang-makefile">all : server
.PHONY : all

src = $(wildcard ./*.c) # wildcard函数：显示指定路径下指定文件类型的所有文件
obj = $(patsubst ./%.c, ./%.o, $(src)) # patsubst函数：.c 替换成 .o

LIBS := -lpthread #相比多进程只是多了这一句，这句为链接线程库pthread
CFLAGS = -I. -g -Wall
CC = gcc
CXX = g++

server : $(obj)
        $(CC) -o server $(obj) $(CFLAGS) $(LIBS)

# $@  表示目标文件
# $<  表示第一个依赖文件
%.o : %.c
        $(CC) -c $(CFLAGS) $< -o $@


# -  即使出错也继续执行后面
.PHONY : clean  # .PHONY 伪目标，有了这句，不管怎样都执行clean
clean :
        -$(RM) server  $(obj)
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>多线程</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>多路IO转接服务器</title>
    <url>/2021/07/09/multiio/</url>
    <content><![CDATA[<h1 id="多路IO转接服务器"><a href="#多路IO转接服务器" class="headerlink" title="多路IO转接服务器"></a>多路IO转接服务器</h1><p>多路IO转接服务器也叫多任务IO服务器。该类服务器的主要思想是，不再由应用程序自己监视客户端连接，而是交给<strong>内核</strong>去替代应用程序监视文件。</p>
<p>主要使用的方法有三种：select、poll、epoll。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><ol>
<li>select能监听的文件描述符个数受限于FD_SIZE，一般为1024，<strong>单纯改变进程打开的文件描述符个数并不能改变select监听文件的个数</strong>。</li>
<li>解决1024以下客户端使用select是很合适的，但如果连接的客户端数量过多，select采用的是<strong>轮询模式</strong>，会大大降低服务器响应效率。</li>
</ol>
<pre class=" language-lang-c"><code class="language-lang-c">/* According to POSIX.1-2001, POSIX.1-2008 */
#include <sys/select.h>

/* According to earlier standards */
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);

/*
参数：
    nfds：        监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态
    readfds：    监控有读数据到达文件描述符集合，传入传出参数
    writefds：    监控写数据到达文件描述符集合，传入传出参数
    exceptfds：    监控异常发生到达文件描述符集合，如带外数据到达异常，传入传出参数
    timeout：    定时阻塞监控时间
                1、NULL，永远阻塞等待
                2、设置timeval，等待固定时间
                3、设置timeval里的时间均为0，检查描述字后立刻返回，轮询
返回值：
    成功：返回三个返回描述符集中包含的文件描述符的数量(即，在readfds、writefds和exceptfds中设置的总位数)，如果超时在任何有趣的事情发生之前过期，该数量可能为零。
    失败：错误返回-1，设置errno
*/
// 文件描述符集操作函数
void FD_CLR(int fd, fd_set *set);
int  FD_ISSET(int fd, fd_set *set);
void FD_SET(int fd, fd_set *set);
void FD_ZERO(fd_set *set);

struct timeval &#123;
    long    tv_sec;         /* seconds */
    long    tv_usec;        /* microseconds */
&#125;;
</code></pre>
<p>应用案例：</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>
#include "wrap.h"

#define MAXSIZE 8192
#define SERV_PORT 8888

int main(void)
&#123;
        int i, maxi, nready, n;
        int lfd, cfd, sfd, maxfd;
        int client[FD_SETSIZE];     // 自定义数组client，防止遍历1024个文件描述符，FD_SETSIZE默认为1024
        char buf[MAXSIZE] = &#123;0&#125;;

        struct sockaddr_in serv_addr, clie_addr;
        socklen_t clie_addr_len;
        fd_set rset, allset;      // rset 读事件文件描述符集合 allset 用于暂存

        char clientip[256];


        lfd = Socket(AF_INET, SOCK_STREAM, 0);

        bzero(&serv_addr, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port = htons(SERV_PORT);
        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  // 指定本地任意IP
        //inet_pton(AF_INET, "192.168.10.100", &serv_addr.sin_addr.s_addr);

        Bind(lfd, (const struct sockaddr *)&serv_addr, (socklen_t)sizeof(serv_addr));
        Listen(lfd, 128); // 设置同一时刻连接服务器的上限，操作系统运行最大监听数为128

        maxfd = lfd;  // 刚开始lfd即为最大文件描述符

        maxi = -1;    // 用-1初始化client[]
        for(i = 0; i < FD_SETSIZE; i++)
                client[i] = -1;

        FD_ZERO(&allset);   // 构造select监控文件描述符集
        FD_SET(lfd, &allset);

        printf("Accepting client connect ...\n");

        while(1)
        &#123;
                rset = allset;  // 每次循环时都重新设置select监控信号集，因为select函数会修改其值
                nready = select(maxfd+1, &rset, NULL, NULL, NULL);
                if(nready < 0)
                &#123;
                        perror("select error");
                        exit(1);
                &#125;

                // 如果有新的客户端连接请求
                if(FD_ISSET(lfd, &rset))
                &#123;
                  clie_addr_len = sizeof(clie_addr);
                  cfd = Accept(lfd, (struct sockaddr *)&clie_addr, &clie_addr_len); // 阻塞监听客户端连接请求
                  printf("rcv from %s at port %d\n",
                                inet_ntop(AF_INET, &clie_addr.sin_addr.s_addr, clientip, sizeof(clientip)),
                                ntohs(clie_addr.sin_port));

                  // 找到client[]中没有用的位置
                  // 保存accept返回的文件描述符到client[]
                  for(i = 0; i < FD_SETSIZE; i++)
                  &#123;
                    if(client[i] < 0)
                    &#123;
                      client[i] = cfd;
                      printf("add a new client[%d] = %d\n", i, cfd);
                      break;
                    &#125;
                  &#125;

                  // 达到select能监控的文件个数上限 1024
                  if(i == FD_SETSIZE)
                  &#123;
                    fputs("too many clients\n", stderr);
                  &#125;

                  // 向监控文件描述符集合allset添加新的文件描述符cfd
                  FD_SET(cfd, &allset);
                  if(cfd > maxfd)
                          maxfd = cfd;

                  // 保证maxi存的总是client[]最后一个元素的下标
                  if(i > maxi)
                          maxi = i;

                  if(--nready == 0)
                          continue;

                &#125;

                // 检测那个client有数据就绪
                for(i = 0; i <= maxi; i++)
                &#123;
                  if((sfd = client[i]) < 0)
                          continue;

                  if(FD_ISSET(sfd, &rset))
                  &#123;
                    printf("Ready to read client data.\n");

                    // 当client关闭连接时，服务器端也关闭对应连接
                    if((n = Read(sfd, buf, sizeof(buf))) == 0)
                    &#123;
                      Close(sfd);
                      // 解除select对此文件描述符的监控
                      FD_CLR(sfd, &allset);
                      client[i] = -1;
                    &#125;
                    else if(n > 0)
                    &#123;
                      for(int j = 0; j < n; j++)
                              buf[j] = toupper(buf[j]);
                      sleep(10);
                      Write(sfd, buf, n);
                      Write(STDOUT_FILENO, buf, n);
                    &#125;
                    if(--nready == 0)
                            break;    // 跳出for，但还在while
                  &#125;
                &#125;
        &#125;
        Close(lfd);
        return 0;
&#125;
</code></pre>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll是select的升级版。特点：</p>
<ol>
<li>poll可以突破1024个打开文件描述符的上限。</li>
<li>监听、返回集合是分离的。</li>
<li>搜索范围变小。</li>
</ol>
<p>ulimit - a 命令可以查看允许打开的文件描述符个数。</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 13312
max locked memory       (kbytes, -l) 65536
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 13312
virtual memory          (kbytes, -v) unlimited
file locks
</code></pre>
<p>open files 是允许打开的文件描述符个数。</p>
<p>使用命令cat查看一个进程可以打开的socket描述符上线，这个是根据计算机硬件条件能打开文件描述符的最大值。</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">cat /proc/sys/fs/file-max
</code></pre>
<p>如果有需要，可以通过修改配置文件的方式修改该上限值。修改完重启或者注销用户即可生效。</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">sudo vim /etc/security/limits.conf
在文件尾部写入以下配置，soft软限制，hard硬限制。
*               soft    nofile          3000
*               hard    nofile          10000
</code></pre>
<p>应用案例：</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
/*
参数：
    fds：监控数组的首地址
    nfds：监控数组中需要监控的文件描述符数量
    timeout：-1：阻塞等待；0：立即返回；>0：等待指定时长。
返回值：
    成功：返回满足条件的文件描述符个数
    失败：返回-1，设置errno
*/
struct pollfd &#123;
    int   fd;         /* file descriptor 要监听的文件描述符*/
    short events;     /* requested events 监听该文件描述符的什么事件 POLLIN\POLLOUT\POLLERR*/
    short revents;    /* returned events 满足条件返回的事件*/
&#125;;
/*
POLLIN        普通或带外优先数据可读，即POLLRDNORM | POLLRDBAND
*/
</code></pre>
<p>应用案例：</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <poll.h>
#include <errno.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include "wrap.h"

#define MAXSIZE 1024
#define SERV_PORT 8888
#define MAXLINE 80
#define OPEN_MAX 3000

int main(void)
&#123;
        ssize_t n;
        int i, maxi;
        int nready;             // 接收poll返回值，记录满足监听事件的fd个数
        int lfd, cfd, sfd;
        char buf[MAXLINE] = &#123;0&#125;;

        struct sockaddr_in serv_addr, clie_addr;
        socklen_t clie_addr_len;
        struct pollfd client[OPEN_MAX]; // poll数组

        char clientip[INET_ADDRSTRLEN]; // 暂存连接的客户端ip


        lfd = Socket(AF_INET, SOCK_STREAM, 0);

        // 设置端口复用
        int opt = 1;
        setsockopt(lfd, SOL_SOCKET,  SO_REUSEADDR, &opt, sizeof(opt));

        bzero(&serv_addr, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port = htons(SERV_PORT);
        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  // 指定本地任意IP
        //inet_pton(AF_INET, "192.168.10.100", &serv_addr.sin_addr.s_addr);

        Bind(lfd, (const struct sockaddr *)&serv_addr, (socklen_t)sizeof(serv_addr));
        Listen(lfd, 128); // 设置同一时刻连接服务器的上限，操作系统运行最大监听数为128

        // 要监听的第一个文件描述符，存入client[0]
        client[0].fd = lfd;
        // lfd 监听普通读事件
        client[0].events = POLLIN;

        //用-1初始化client[]里面剩下的元素 0也是文件描述符，不能用
        for(i = 1; i < OPEN_MAX; i++)
                client[i].fd = -1;

        // client[]数组中有效元素的最大元素下标
        maxi = 0;

        printf("Accept to connecting...\n");
        for(;;)
        &#123;
                // 阻塞监听是否有客户端连接请求
                nready = poll(client, maxi+1, -1);

                // lfd有读事件就绪
                if(client[0].revents & POLLIN)
                &#123;
                        clie_addr_len = sizeof(clie_addr);
                        cfd = Accept(lfd, (struct sockaddr *)&clie_addr, &clie_addr_len); // 阻塞监听客户端连接请求
                        printf("rcv from %s at port %d\n",
                                        inet_ntop(AF_INET, &clie_addr.sin_addr.s_addr, clientip, sizeof(clientip)),
                                        ntohs(clie_addr.sin_port));
                        for(i = 1; i < OPEN_MAX; i++)
                        &#123;
                                if(client[i].fd < 0)
                                &#123;

                                        // 找到client[]中空闲的位置，存放accept返回的cfd
                                        client[i].fd = cfd;
                                        break;
                                &#125;
                        &#125;

                        // 达到最大客户端书
                        if(i == OPEN_MAX)
                        &#123;
                                perror("too many clients");
                                exit(1);
                        &#125;

                        // 设置刚刚返回的cfd，监控读事件
                        client[i].events = POLLIN;

                        // 更新client[]中最大元素的下标
                        if(i > maxi)
                                maxi = i;

                        // 没有更多的就绪事件时，继续返回poll阻塞
                        if(--nready == 0)
                                continue;
                &#125;

                // 前面的if没有满足，说明没有lfd满足，则检测client[]看是哪个cfd就绪
                for(i = 0; i <= maxi; i++)
                &#123;
                        if((sfd = client[i].fd) < 0)
                                continue;

                        if(client[i].revents & POLLIN)
                        &#123;
                                printf("Ready to read client data.\n");

                                // 当client关闭连接时，服务器端也关闭对应连接
                                if((n = Read(sfd, buf, sizeof(buf))) == 0)
                                &#123;
                                        // 说明客户端先关闭连接
                                        printf("client[%d] closed connection\n", i);
                                        Close(sfd);
                                        // 解除poll对此文件描述符的监控
                                        client[i].fd = -1;
                                &#125;
                                else if(n > 0)
                                &#123;
                                        for(int j = 0; j < n; j++)
                                                buf[j] = toupper(buf[j]);
                                        sleep(10);
                                        Write(sfd, buf, n);
                                        Write(STDOUT_FILENO, buf, n);
                                &#125;
                                else
                                &#123;
                                        // connection reset by client
                                        // 收到RST标志
                                        if(errno == ECONNRESET)
                                        &#123;
                                                printf("client[%d] aborted connection\n", i);
                                                Close(sfd);
                                                client[i].fd = -1;
                                        &#125;
                                        else
                                        &#123;
                                                perror("read error");
                                                exit(1);
                                        &#125;
                                &#125;
                                if(--nready == 0)
                                        break;    // 跳出for，但还在while
                        &#125;

                &#125;
        &#125;
        Close(lfd);
        return 0;
&#125;
</code></pre>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另外一点原因就是获取事件的时候，它无需遍历整个被侦听的描述符集合，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合即可。</p>
<p>epoll是Linux大规模并发网络程序中的热门首选模型。</p>
<p>epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</p>
<h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><p>1、创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。</p>
<blockquote>
<p>平衡二叉树：左子树和右子树的高度差小于1的二叉树。</p>
<p>平衡二叉树查找最快的方法：二分法。</p>
</blockquote>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/epoll.h>
int epoll_create(int size);  
/* 
    size:监听的文件描述符的个数，是给Linux内核的一个参考，实际监听的个数可以大于它。实际上用于一个红黑树。
    返回值：一个文件描述符epfd，这个epfd文件描述符指向一个红黑树（效率较高的平衡二叉树）的树根
*/
</code></pre>
<p>2、控制某个epoll监听的文件描述符上的事件：注册、修改、删除。</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/epoll.h>
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
/*
    epfd：为epoll_create的句柄
    op：表示动作，用3个宏来表示：
        EPOLL_CTL_ADD (注册新的fd到epfd)(添加一个红黑树的节点)，
        EPOLL_CTL_MOD (修改已经注册的fd的监听事件)(修改一个红黑树的节点)，
        EPOLL_CTL_DEL (从epfd删除一个fd)(删除一个红黑树的节点)；
    fd：对哪个文件描述符进行注册、修改、删除。
    event：告诉内核要监听的事件，传入参数
*/

typedef union epoll_data &#123;
    void        *ptr;
    int          fd;
    uint32_t     u32;
    uint64_t     u64;
&#125; epoll_data_t;

struct epoll_event &#123;
    uint32_t     events;      /* Epoll events */
    epoll_data_t data;        /* User data variable */
&#125;;
/*
    events：EPOLLIN\EPOLLOUT\EPOLLERR...
*/
</code></pre>
<p>3、等待所监控文件描述符上有事件的产生，类似于select()调用</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/epoll.h>
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
/*
参数：
    epfd：为epoll_create的句柄
    events：用来存内核得到事件的集合，数组，传出参数
    maxevents：告诉内核这个events多大，这个maxevents的值不能大于epoll_create()时的size，数组容量
    timeout：超时时间
        -1：阻塞
        0：立即返回，非阻塞
        >0：指定阻塞多少毫秒
返回值：
    成功：返回有多少文件描述符就绪
    时间到时：返回0
    失败：返回-1
*/
</code></pre>
<h3 id="应用案例："><a href="#应用案例：" class="headerlink" title="应用案例："></a>应用案例：</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <errno.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include "wrap.h"

#define SERV_PORT 8888
#define MAXLINE 8192
#define OPEN_MAX 3000

int main(void)
&#123;
        ssize_t efd, res, nready;
        int i, n, num;
        int lfd, cfd, sfd;
        char buf[MAXLINE] = &#123;0&#125;;

        struct sockaddr_in serv_addr, clie_addr;
        socklen_t clie_addr_len;
        struct epoll_event tep, ep[OPEN_MAX];   // tep：epoll_ctl参数； ep[]：epoll_wait参数
        char clientip[INET_ADDRSTRLEN]; // 暂存连接的客户端ip


        lfd = Socket(AF_INET, SOCK_STREAM, 0);

        // 设置端口复用
        int opt = 1;
        setsockopt(lfd, SOL_SOCKET,  SO_REUSEADDR, &opt, sizeof(opt));

        bzero(&serv_addr, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port = htons(SERV_PORT);
        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  // 指定本地任意IP
        //inet_pton(AF_INET, "192.168.10.100", &serv_addr.sin_addr.s_addr);

        Bind(lfd, (const struct sockaddr *)&serv_addr, (socklen_t)sizeof(serv_addr));
        Listen(lfd, 128); // 设置同一时刻连接服务器的上限，操作系统运行最大监听数为128

        efd = epoll_create(OPEN_MAX);   // 创建epoll模型，efd指向红黑树根节点
        if(efd == -1)
        &#123;
                perror("epoll_create error");
                exit(1);
        &#125;

        // 指定lfd的监听事件为读
        tep.events = EPOLLIN;
        tep.data.fd = lfd;

        // 将lfd及对应的结构体设置到树上，efd可找到该树
        res = epoll_ctl(efd, EPOLL_CTL_ADD, lfd, &tep);
        if(res == -1)
        &#123;
                perror("epoll_ctl error");
                exit(1);
        &#125;

        printf("Accept to connecting...\n");
        for(;;)
        &#123;
                // epoll为server阻塞监听事件，ep为struct
                // epoll_event类型的数组，OPEN_MAX为数组容量，-1表示阻塞等待
                nready = epoll_wait(efd, ep, OPEN_MAX, -1);
                if(nready == -1)
                &#123;
                        perror("epoll_wait error");
                        exit(1);
                &#125;

                for(i = 0; i < nready; i++)
                &#123;
                        // 如果不是读事件，跳过后面，继续下一次循环
                        if(!(ep[i].events & EPOLLIN))
                                continue;

                        // 判断满足事件的fd是否为lfd
                        if(ep[i].data.fd == lfd)
                        &#123;

                                clie_addr_len = sizeof(clie_addr);
                                cfd = Accept(lfd, (struct sockaddr *)&clie_addr, &clie_addr_len); // 阻塞监听客户端连接请求
                                printf("rcv from %s at port %d\n",
                                                inet_ntop(AF_INET, &clie_addr.sin_addr.s_addr, clientip, sizeof(clientip)),
                                                ntohs(clie_addr.sin_port));
                                printf("cfd[%d] --- client[%d]\n", cfd, ++num);

                                // 将新连接的客户端加入到epoll的读事件监听
                                tep.events = EPOLLIN;
                                tep.data.fd = cfd;
                                res = epoll_ctl(efd, EPOLL_CTL_ADD, cfd, &tep);
                                if(res == -1)
                                &#123;
                                        perror("epoll_ctl error");
                                        exit(1);
                                &#125;
                        &#125;
                        else // 不是lfd
                        &#123;
                                sfd = ep[i].data.fd;
                                n = Read(sfd, buf, MAXLINE);
                                // 读到0，说明客户端关闭连接
                                // 则需要将该文件描述符从红黑树删除
                                if(n == 0)
                                &#123;
                                        res = epoll_ctl(efd, EPOLL_CTL_DEL, sfd, NULL);
                                        if(res == -1)
                                        &#123;
                                                perror("epoll_ctl error");
                                                exit(1);
                                        &#125;
                                        Close(sfd); // 关闭与该客户端的连接
                                        printf("client[%d] closed connection\n", sfd);
                                &#125;
                                else if(n < 0)
                                &#123;
                                        perror("read n < 0 error:");
                                        res = epoll_ctl(efd, EPOLL_CTL_DEL, sfd, NULL);
                                        if(res == -1)
                                        &#123;
                                                perror("epoll_ctl error");
                                                exit(1);
                                        &#125;
                                        Close(sfd); // 关闭与该客户端的连接
                                &#125;
                                else
                                &#123;
                                        for(i = 0; i < n; i++)
                                        &#123;
                                                buf[i] = toupper(buf[i]);
                                        &#125;
                                        Write(STDOUT_FILENO, buf, n);
                                        Write(sfd, buf, n);
                                &#125;
                        &#125;
                &#125;


        &#125;
        Close(lfd);
        return 0;
&#125;
</code></pre>
<h3 id="水平触发-epoll-LT-和边缘触发-epoll-ET"><a href="#水平触发-epoll-LT-和边缘触发-epoll-ET" class="headerlink" title="水平触发(epoll LT)和边缘触发(epoll ET)"></a>水平触发(epoll LT)和边缘触发(epoll ET)</h3><p>水平触发(epoll LT)：只要文件描述符的读写缓冲区里还有数据没被读走，就会一直触发，也就是再次调用epoll_wait时会再次立刻返回，直到读写缓冲区里的数据被完全读走。epoll默认就是这种模式。</p>
<p>边缘触发(epoll ET)：只当文件描述符的读写缓冲区的来了一次数据，才会触发一次，再次调用epoll_wait时不会立刻返回，即使没有把缓冲区里的数据完全读走，直到文件描述符的读写缓冲区再一次来了新数据才会触发返回。</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include <errno.h>
#include <unistd.h>

#define MAXLINE 10

int main(void)
&#123;
  int efd, i;
  int pfd[2];
  pid_t pid;
  char buf[MAXLINE];
  char ch = 'a';

  pipe(pfd);
  pid = fork();

  // 子进程 写
  if(pid == 0)
  &#123;
    close(pfd[0]);
    while(1)
    &#123;
      // aaaa\n
      for(i = 0; i < MAXLINE/2; i++)
      &#123;
        buf[i] = ch;
      &#125;
      buf[i - 1] = '\n';
      ch++;
      // bbbb\n
      for(; i < MAXLINE; i++)
      &#123;
        buf[i] = ch;
      &#125;
      buf[i - 1] = '\n';
      ch++;
      // aaaa\nbbbb\n
      write(pfd[1], buf, sizeof(buf));
      sleep(1);
      write(STDOUT_FILENO, "sleep 1\n", 8);
      sleep(1);
      write(STDOUT_FILENO, "sleep 2\n", 8);
      sleep(1);
      write(STDOUT_FILENO, "sleep 3\n", 8);
      sleep(1);
      write(STDOUT_FILENO, "sleep 4\n", 8);
      sleep(1);
      write(STDOUT_FILENO, "sleep 5\n", 8);
    &#125;
    close(pfd[1]);
  &#125;
  // 父进程 读
  else if(pid > 0)
  &#123;
    struct epoll_event event;       // epoll_ctl 设置的最后一个参数
    struct epoll_event revent[10];  // epoll_wait 就绪返回数组
    int ret, len;

    close(pfd[1]);
    efd = epoll_create(10);          // 创建可以容纳10个节点的红黑树，返回红黑树树根

    event.events = EPOLLIN | EPOLLET; // ET边缘触发
    // event.events = EPOLLIN;        // LT水平触发
    event.data.fd = pfd[0];
    ret = epoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], & event);
    if(ret == -1)
    &#123;
      perror("epoll_ctl error");
      exit(1);
    &#125;

    while(1)
    &#123;
      write(STDOUT_FILENO, "epoll_wait...\n", 14);
      ret = epoll_wait(efd, revent, MAXLINE, -1); // -1阻塞
      printf("ret %d\n", ret);
      if(revent[0].data.fd == pfd[0])
      &#123;
        len = read(pfd[0], buf, MAXLINE/2);
        write(STDOUT_FILENO, buf, len);
      &#125;
    &#125;
    close(pfd[0]);
    close(efd);
  &#125;
  else
  &#123;
    perror("fork error");
    exit(1);
  &#125;

  return 0;

&#125;
</code></pre>
<h3 id="epoll非阻塞IO"><a href="#epoll非阻塞IO" class="headerlink" title="epoll非阻塞IO"></a>epoll非阻塞IO</h3><p>这是非常典型的epoll的应用，常用模式这种模式可以减少epoll_wait的调用，提高程序的效率。因为是非阻塞IO，所有需要对用fcntl()对cfd套接字进行非阻塞设置。</p>
<pre class=" language-lang-c"><code class="language-lang-c">// client.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>

#define MAXLINE 10
#define SERV_PORT 8888
int main(void)
&#123;
        struct sockaddr_in servaddr;
        char buf[MAXLINE];
        char ch = 'a';
        int sfd, i;

        sfd = socket(AF_INET, SOCK_STREAM,0);

        bzero(&servaddr, sizeof(servaddr));
        servaddr.sin_family = AF_INET;
        inet_pton(AF_INET, "127.0.0.1", &servaddr.sin_addr);
        servaddr.sin_port = htons(SERV_PORT);

        connect(sfd, (struct sockaddr *)&servaddr, sizeof(servaddr));

        while(1)
        &#123;
                // aaaa\n
                for(i = 0; i < MAXLINE/2; i++)
                &#123;
                        buf[i] = ch;
                &#125;
                buf[i - 1] = '\n';
                ch++;
                // bbbb\n
                for(; i < MAXLINE; i++)
                &#123;
                        buf[i] = ch;
                &#125;
                buf[i - 1] = '\n';
                ch++;
                // aaaa\nbbbb\n
                write(sfd, buf, sizeof(buf));
                sleep(1);
                write(STDOUT_FILENO, "sleep 1\n", 8);
                sleep(1);
                write(STDOUT_FILENO, "sleep 2\n", 8);
                sleep(1);
                write(STDOUT_FILENO, "sleep 3\n", 8);
                sleep(1);
                write(STDOUT_FILENO, "sleep 4\n", 8);
                sleep(1);
                write(STDOUT_FILENO, "sleep 5\n", 8);

        &#125;
        close(sfd);
        return 0;
&#125;
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">// server.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include <errno.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <strings.h>
#include <fcntl.h>

#define MAXLINE 10
#define SERV_PORT 8888

int main(void)
&#123;
  int efd;
  int lfd, cfd;
  char buf[MAXLINE];
  char ipstr[INET_ADDRSTRLEN];

  struct sockaddr_in servaddr, cliaddr;
  socklen_t cliaddr_len;

  lfd = socket(AF_INET, SOCK_STREAM, 0);

  bzero(&servaddr, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_port = htons(SERV_PORT);
  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);

  bind(lfd, (struct sockaddr *)&servaddr, sizeof(servaddr));

  listen(lfd, 128);

  struct epoll_event ev;
  struct epoll_event rev[10];
  int res, len;

  efd = epoll_create(10);
  ev.events = EPOLLIN | EPOLLET;  // ET边沿触发
  //ev.events = EPOLLIN;         // LT水平触发

  printf("Accepting connections...\n");

  cliaddr_len = sizeof(cliaddr);
  cfd = accept(lfd, (struct sockaddr *)&cliaddr, &cliaddr_len);
  printf("received from %s at port %d\n",
                  inet_ntop(AF_INET, &cliaddr.sin_addr, ipstr, sizeof(ipstr)),
                  ntohs(cliaddr.sin_port));

  // 修改cfd为非阻塞读
  int flag = fcntl(cfd, F_GETFL);
  flag |= O_NONBLOCK;
  fcntl(cfd, F_SETFL, flag);

  ev.data.fd = cfd;
  epoll_ctl(efd, EPOLL_CTL_ADD, cfd, &ev);

  while(1)
  &#123;
    printf("epoll_wait begin\n");
    res = epoll_wait(efd, rev, 10, -1);
    printf("epoll_wait end\n");
    printf("res %d\n", res);

    if(rev[0].data.fd == cfd)
    &#123;
      // 非阻塞读，轮询
      while((len = read(cfd, buf, MAXLINE/2)) > 0)
        write(STDOUT_FILENO, buf, len);
    &#125;
  &#125;

  return 0;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>多路IO</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>select</tag>
        <tag>poll</tag>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL数据库的基本操作</title>
    <url>/2021/07/03/mysql/</url>
    <content><![CDATA[<h1 id="MYSQL数据库的基本操作"><a href="#MYSQL数据库的基本操作" class="headerlink" title="MYSQL数据库的基本操作"></a>MYSQL数据库的基本操作</h1><h2 id="1、root登录mysql"><a href="#1、root登录mysql" class="headerlink" title="1、root登录mysql"></a>1、root登录mysql</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql -uroot -p
Enter password: *****
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 8
Server version: 8.0.25 MySQL Community Server - GPL

Copyright (c) 2000, 2021, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
</code></pre>
<h2 id="2、查看数据库"><a href="#2、查看数据库" class="headerlink" title="2、查看数据库"></a>2、查看数据库</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
</code></pre>
<h2 id="3、查看表"><a href="#3、查看表" class="headerlink" title="3、查看表"></a>3、查看表</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> use mysql
Database changed
mysql> show tables;
+------------------------------------------------------+
| Tables_in_mysql                                      |
+------------------------------------------------------+
| columns_priv                                         |
| component                                            |
| db                                                   |
| default_roles                                        |
| engine_cost                                          |
| func                                                 |
| general_log                                          |
| global_grants                                        |
| gtid_executed                                        |
| help_category                                        |
| help_keyword                                         |
| help_relation                                        |
| help_topic                                           |
| innodb_index_stats                                   |
| innodb_table_stats                                   |
| password_history                                     |
| plugin                                               |
| procs_priv                                           |
| proxies_priv                                         |
| replication_asynchronous_connection_failover         |
| replication_asynchronous_connection_failover_managed |
| role_edges                                           |
| server_cost                                          |
| servers                                              |
| slave_master_info                                    |
| slave_relay_log_info                                 |
| slave_worker_info                                    |
| slow_log                                             |
| tables_priv                                          |
| time_zone                                            |
| time_zone_leap_second                                |
| time_zone_name                                       |
| time_zone_transition                                 |
| time_zone_transition_type                            |
| user                                                 |
+------------------------------------------------------+
</code></pre>
<h2 id="4、退出数据库"><a href="#4、退出数据库" class="headerlink" title="4、退出数据库"></a>4、退出数据库</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> exit;
Bye
</code></pre>
<h2 id="5、创建数据库"><a href="#5、创建数据库" class="headerlink" title="5、创建数据库"></a>5、创建数据库</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> create database mydb01;
</code></pre>
<h2 id="6、创建表"><a href="#6、创建表" class="headerlink" title="6、创建表"></a>6、创建表</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> create table employee(id int, name varchar(30), sex int, birthday date, salary double, entry_date date, resume text);
</code></pre>
<h2 id="7、创建表数据"><a href="#7、创建表数据" class="headerlink" title="7、创建表数据"></a>7、创建表数据</h2><pre class=" language-lang-sql"><code class="language-lang-sql">insert into employee values(1,'韩信',1,'1997-07-07',15000,'2020-02-02','突进刺客');
insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(2,'兰陵王',1,'1996-06-06',12000,'2020-01-01','脆皮刺客');
insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(3,'亚瑟',1,'1000-01-01',8000,'2020-10-01','前排坦克');
</code></pre>
<h2 id="查看表信息"><a href="#查看表信息" class="headerlink" title="查看表信息"></a>查看表信息</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> desc employee;
+------------+-------------+------+-----+---------+-------+
| Field      | Type        | Null | Key | Default | Extra |
+------------+-------------+------+-----+---------+-------+
| id         | int         | YES  |     | NULL    |       |
| name       | varchar(30) | YES  |     | NULL    |       |
| sex        | int         | YES  |     | NULL    |       |
| birthday   | date        | YES  |     | NULL    |       |
| salary     | double      | YES  |     | NULL    |       |
| entry_date | date        | YES  |     | NULL    |       |
| resume     | text        | YES  |     | NULL    |       |
+------------+-------------+------+-----+---------+-------+
</code></pre>
<h2 id="8、查看表数据"><a href="#8、查看表数据" class="headerlink" title="8、查看表数据"></a>8、查看表数据</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> select * from employee;
+------+--------+------+------------+--------+------------+----------+
| id   | name   | sex  | birthday   | salary | entry_date | resume   |
+------+--------+------+------------+--------+------------+----------+
|    1 | 韩信   |    1 | 1997-07-07 |  15000 | 2020-02-02 | 突进刺客 |
|    2 | 兰陵王 |    1 | 1996-06-06 |  12000 | 2020-01-01 | 脆皮刺客 |
|    3 | 亚瑟   |    1 | 1000-01-01 |   8000 | 2020-10-01 | 前排坦克 |
+------+--------+------+------------+--------+------------+----------+
</code></pre>
<h2 id="修改某个项的内容"><a href="#修改某个项的内容" class="headerlink" title="修改某个项的内容"></a>修改某个项的内容</h2><pre class=" language-lang-sql"><code class="language-lang-sql">mysql> update employee set resume='偷家小贼' where id=1;
Query OK, 1 row affected (0.01 sec)

mysql> select * from employee;
+------+--------+------+------------+--------+------------+----------+
| id   | name   | sex  | birthday   | salary | entry_date | resume   |
+------+--------+------+------------+--------+------------+----------+
|    1 | 韩信   |    1 | 1997-07-07 |  15000 | 2020-02-02 | 偷家小贼 |
|    2 | 兰陵王 |    1 | 1996-06-06 |  12000 | 2020-01-01 | 脆皮刺客 |
|    3 | 亚瑟   |    1 | 1000-01-01 |   8000 | 2020-10-01 | 前排坦克 |
+------+--------+------+------------+--------+------------+----------+
</code></pre>
<h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><pre class=" language-lang-sql"><code class="language-lang-sql">create table students(id int, name varchar(20), chinese int, english int, math int);
insert into students(id, name, chinese, english, math) values(1, '黄真', 80, 85, 90);
insert into students(id, name, chinese, english, math) values(2, '归辛树', 90, 95, 95);
insert into students(id, name, chinese, english, math) values(3, '李寻欢', 80, 96, 96);
insert into students(id, name, chinese, english, math) values(4, '叶开', 81, 97, 85);
insert into students(id, name, chinese, english, math) values(5, '袁承志', 85, 84, 90);
insert into students(id, name, chinese, english, math) values(6, '何红药', 92, 85, 87);
insert into students(id, name, chinese, english, math) values(7, '何铁手', 75, 81, 80);
insert into students(id, name, chinese, english, math) values(8, '夏雪宜', 77, 80, 79);
insert into students(id, name, chinese, english, math) values(9, '任我行', 95, 85, 85);
insert into students(id, name, chinese, english, math) values(10, '岳不群', 94, 85, 84);


增加一列：
alter table students add class_id int;

id <= 5 为1班， id > 5 为2班
update students set class_id=1 where id <= 5;

select ceil(id/5),id from students;

update students set class_id=ceil(id/5);

求平均
select avg(english),class_id from students group by class_id;

求和
select sum(chinese+math+english), class_id from students group by class_id;
+---------------------------+----------+
| sum(chinese+math+english) | class_id |
+---------------------------+----------+
|                      1329 |        1 |
|                      1264 |        2 |
+---------------------------+----------+

找到总分大于1300的
select sum(chinese+english+math), class_id from students group by class_id having sum(chinese+english+math)>1300;
+---------------------------+----------+
| sum(chinese+english+math) | class_id |
+---------------------------+----------+
|                      1329 |        1 |
+---------------------------+----------+

查看当前时间
select now() from dual;
+---------------------+
| now()               |
+---------------------+
| 2021-06-19 14:44:07 |
+---------------------+


select now()-1,now(),now()+1 from dual;
+----------------+---------------------+----------------+
| now()-1        | now()               | now()+1        |
+----------------+---------------------+----------------+
| 20210619164648 | 2021-06-19 16:46:49 | 20210619164650 |
+----------------+---------------------+----------------+


求今天、昨天、明天
select date_add(now(), interval -1 day), now(), date_add(now(), interval 1 day) from dual;
+----------------------------------+---------------------+---------------------------------+
| date_add(now(), interval -1 day) | now()               | date_add(now(), interval 1 day) |
+----------------------------------+---------------------+---------------------------------+
| 2021-06-18 16:53:37              | 2021-06-19 16:53:37 | 2021-06-20 16:53:37             |
+----------------------------------+---------------------+---------------------------------+
1 row in set (0.07 sec)

select addtime(now(),'0:1:0'),now() from dual;
+------------------------+---------------------+
| addtime(now(),'0:1:0') | now()               |
+------------------------+---------------------+
| 2021-06-19 17:00:34    | 2021-06-19 16:59:34 |
+------------------------+---------------------+

字符串
select concat('hello ', 'mysql', 'yyds', '123.') from dual;
+-------------------------------------------+
| concat('hello ', 'mysql', 'yyds', '123.') |
+-------------------------------------------+
| hello mysqlyyds123.                       |
+-------------------------------------------+
1 row in set (0.00 sec)
</code></pre>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>信号</title>
    <url>/2021/07/05/signal/</url>
    <content><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="1、信号的概念"><a href="#1、信号的概念" class="headerlink" title="1、信号的概念"></a>1、信号的概念</h2><h3 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h3><ol>
<li>简单。</li>
<li>不能携带大量信息。</li>
<li>满足某个特设条件才能发送。</li>
</ol>
<h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>A给B发送信号，B收到信号前执行自己的代码，收到信号好后，不管执行到程序的什么位置，都要暂停运行， 去处理信号，处理完毕再继续运行。与硬件中断类似，但信号是软件层面上实现的终端，常称为“软中断”。</p>
<blockquote>
<p><strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></p>
</blockquote>
<h3 id="阻塞信号集（信号屏蔽字）"><a href="#阻塞信号集（信号屏蔽字）" class="headerlink" title="阻塞信号集（信号屏蔽字）"></a>阻塞信号集（信号屏蔽字）</h3><p>将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后（解除屏蔽后），<code>未决信号集</code>的对应信号位置将不再立刻翻转，常为1。</p>
<h3 id="未决信号集"><a href="#未决信号集" class="headerlink" title="未决信号集"></a>未决信号集</h3><ol>
<li>信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理，对应位翻转回0。这一时刻“光速”。</li>
<li>信号产生后由于某些原因（主要是阻塞）不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</li>
</ol>
<h3 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a>信号的编号</h3><pre class=" language-lang-shell"><code class="language-lang-shell">cyh@cyh-virtual-machine:~$kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
</code></pre>
<ul>
<li><p>1-31为普通信号（常规信号）。</p>
<ul>
<li>常用2、3、7、8、9、10、11、12、13、14、15、17、19、20号信号</li>
</ul>
</li>
<li><p>34-64为实时信号，一般是在嵌入式驱动开发中才用得到，应用层开发一般不用。</p>
</li>
</ul>
<p>可通过<code>man 7 signal</code>查看详细说明</p>
<pre class=" language-lang-c"><code class="language-lang-c">Signal      Standard   Action   Comment
────────────────────────────────────────────────────────────────────────
SIGABRT      P1990      Core    Abort signal from abort(3)
SIGALRM      P1990      Term    Timer signal from alarm(2)
SIGBUS       P2001      Core    Bus error (bad memory access)
SIGCHLD      P1990      Ign     Child stopped or terminated
SIGCLD         -        Ign     A synonym for SIGCHLD
SIGCONT      P1990      Cont    Continue if stopped
SIGEMT         -        Term    Emulator trap
SIGFPE       P1990      Core    Floating-point exception
SIGHUP       P1990      Term    Hangup detected on controlling terminal
                               or death of controlling process
SIGILL       P1990      Core    Illegal Instruction
SIGINFO        -                A synonym for SIGPWR
SIGINT       P1990      Term    Interrupt from keyboard
SIGIO          -        Term    I/O now possible (4.2BSD)
SIGIOT         -        Core    IOT trap. A synonym for SIGABRT
SIGKILL      P1990      Term    Kill signal
SIGLOST        -        Term    File lock lost (unused)
SIGPIPE      P1990      Term    Broken pipe: write to pipe with no
                               readers; see pipe(7)
SIGPOLL      P2001      Term    Pollable event (Sys V).
                               Synonym for SIGIO
SIGPROF      P2001      Term    Profiling timer expired
SIGPWR         -        Term    Power failure (System V)
SIGQUIT      P1990      Core    Quit from keyboard
SIGSEGV      P1990      Core    Invalid memory reference
SIGSTKFLT      -        Term    Stack fault on coprocessor (unused)
SIGSTOP      P1990      Stop    Stop process
SIGTSTP      P1990      Stop    Stop typed at terminal
SIGSYS       P2001      Core    Bad system call (SVr4);
                               see also seccomp(2)
SIGTERM      P1990      Term    Termination signal

SIGTRAP      P2001      Core    Trace/breakpoint trap
SIGTTIN      P1990      Stop    Terminal input for background process
SIGTTOU      P1990      Stop    Terminal output for background process
SIGUNUSED      -        Core    Synonymous with SIGSYS
SIGURG       P2001      Ign     Urgent condition on socket (4.2BSD)
SIGUSR1      P1990      Term    User-defined signal 1
SIGUSR2      P1990      Term    User-defined signal 2
SIGVTALRM    P2001      Term    Virtual alarm clock (4.2BSD)
SIGXCPU      P2001      Core    CPU time limit exceeded (4.2BSD);
                               see setrlimit(2)
SIGXFSZ      P2001      Core    File size limit exceeded (4.2BSD);
                               see setrlimit(2)
SIGWINCH       -        Ign     Window resize signal (4.3BSD, Sun)

The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.
//9)SIGKILL、19)SIGSTOP信号，不允许忽略或者捕获，只能执行默认动作。甚至不能将其阻塞。
</code></pre>
<pre class=" language-lang-c"><code class="language-lang-c">Signal        x86/ARM     Alpha/   MIPS   PARISC   Notes
           most others   SPARC
─────────────────────────────────────────────────────────────────
SIGHUP           1           1       1       1
SIGINT           2           2       2       2
SIGQUIT          3           3       3       3
SIGILL           4           4       4       4
SIGTRAP          5           5       5       5
SIGABRT          6           6       6       6
SIGIOT           6           6       6       6
SIGBUS           7          10      10      10
SIGEMT           -           7       7      -
SIGFPE           8           8       8       8
SIGKILL          9           9       9       9
SIGUSR1         10          30      16      16
SIGSEGV         11          11      11      11
SIGUSR2         12          31      17      17
SIGPIPE         13          13      13      13
SIGALRM         14          14      14      14
SIGTERM         15          15      15      15
SIGSTKFLT       16          -       -        7
SIGCHLD         17          20      18      18
SIGCLD           -          -       18      -
SIGCONT         18          19      25      26
SIGSTOP         19          17      23      24

SIGTSTP         20          18      24      25
SIGTTIN         21          21      26      27
SIGTTOU         22          22      27      28
SIGURG          23          16      21      29
SIGXCPU         24          24      30      12
SIGXFSZ         25          25      31      30
SIGVTALRM       26          26      28      20
SIGPROF         27          27      29      21
SIGWINCH        28          28      20      23
SIGIO           29          23      22      22
SIGPOLL                                            Same as SIGIO
SIGPWR          30         29/-     19      19
SIGINFO          -         29/-     -       -
SIGLOST          -         -/29     -       -
SIGSYS          31          12      12      31
SIGUNUSED       31          -       -       31
</code></pre>
<h3 id="默认动作"><a href="#默认动作" class="headerlink" title="默认动作"></a>默认动作</h3><ul>
<li>Term：终止进程，如kill。</li>
<li>Ign：忽略信号（默认即时对该信号忽略操作），如子进程退出时通知父进程的“收尸”信号。</li>
<li>Core：终止进程，生成Core文件。（查验进程死亡原因，用于gdb调试）</li>
<li>Stop：停止（暂停）进程。</li>
<li>Cont：继续运行进程</li>
</ul>
<blockquote>
<p>注意：只有每个信号所对应的事件发生了，该信号才会被递送（但不一定递达），不应该乱发信号！</p>
</blockquote>
<h3 id="信号的处理方式"><a href="#信号的处理方式" class="headerlink" title="信号的处理方式"></a>信号的处理方式</h3><ol>
<li>执行默认动作</li>
<li>忽略（丢弃）</li>
<li>捕捉（调用用户处理函数）</li>
</ol>
<h3 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h3><ol>
<li>编号</li>
<li>名称</li>
<li>事件</li>
<li>默认处理动作</li>
</ol>
<h3 id="产生信号5种方式"><a href="#产生信号5种方式" class="headerlink" title="产生信号5种方式"></a>产生信号5种方式</h3><ol>
<li>按键产生： 2) SIGINT <code>Ctrl+c</code>、20) SIGTSTP <code>Ctrl+z</code>、3) SIGQUIT <code>Ctrl+\</code></li>
<li>系统调用：<code>kill()</code>、<code>raise()</code> 、<code>abort()</code></li>
<li>软件条件产生：定时器alarm</li>
<li>硬件异常产生：非法访问内存（段错误）、除0（浮点数例外）、内存对齐出错（总线错误）</li>
<li>命令产生：kill - 9</li>
</ol>
<h2 id="2、信号产生函数"><a href="#2、信号产生函数" class="headerlink" title="2、信号产生函数"></a>2、信号产生函数</h2><h3 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
</code></pre>
<p>参数：</p>
<ul>
<li><p>pid：进程id</p>
<p>pid &gt;0：发送信号给指定进程。</p>
<p>pid=0：发送信号给 与 调用kill()函数进程属于同一进程组的所有进程。</p>
<p>pid&lt;0：取pid的绝对值|pid|发送给对应进程组。</p>
<p>pid=-1：发送给进程所有权限发送的系统中所有进程。</p>
<p>进程组：每个进程都属于一个进程组，进程组是一个或者多个进程的集合，相互关联，共同完成一个用户概念的任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p>
<p>权限保护：super用户（root）可以发送信号给任何用户，普通用户不能向系统用户发送 信号，在普通用户中，使用<code>kill -9 (root用户的pid)</code>是不能成功的，同时，普通用户也不能给其他普通用户发送信号，终止其进程。只能向自己创建的进程发送信号。普通用户基本原则：发送者实际或有效用户ID == 接收者实际或有效用户ID。</p>
</li>
<li><p>sig：信号类型</p>
</li>
</ul>
<p>返回值：成功返回0，失败返回-1。</p>
<pre class=" language-lang-shell"><code class="language-lang-shell">$ ps ajx
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
      0       1       1       1 ?             -1 Ss       0   0:08 /sbin/init splash
      0       2       0       0 ?             -1 S        0   0:00 [kthreadd]
      2       3       0       0 ?             -1 I<       0   0:00 [rcu_gp]
</code></pre>
<p>父进程ID(PPID)，进程ID(PID )，进程组ID(PGID)，会话组ID(SID)。</p>
<h3 id="raise-和abort"><a href="#raise-和abort" class="headerlink" title="raise()和abort()"></a>raise()和abort()</h3><p>raise函数：给当前进程发送指定信号（自发自收）。raise(signo) == kill(getpid(), signo);</p>
<p>​        int raise(int sig); 成功返回0，失败返回非0值。</p>
<p>abort函数：给自己发送异常终止信号 6) SIGABRT 信号，终止并产生core文件。</p>
<p>​        void abort(void); </p>
<h3 id="alaram"><a href="#alaram" class="headerlink" title="alaram()"></a>alaram()</h3><p>设置定时器，在指定seconds后，内核会给当前进程发送 14) SIGALRM 信号。进程收到该信号，默认终止进程。</p>
<p><strong>注意：每个进程有且只有一个定时器。</strong></p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <unistd.h>
unsigned int alarm(unsigned int seconds); // 返回0或者上一次定时剩余的秒数，不会失败。
</code></pre>
<p>常用alram(0)来取消定时器。</p>
<p><strong>与进程状态无关的自然定时法！！</strong>无论进程处于就绪、运行、挂起（阻塞、暂停）、终止、僵尸…alarm都计时而不会被打断。</p>
<pre class=" language-lang-c"><code class="language-lang-c">// 统计1秒内计算机能数多少个数。
#include <stdio.h>
#include <unistd.h>

int main(void)
&#123;
  alarm(1);
  for(int i = 0; ; i++)
  &#123;
    printf("%d \n", i);
  &#125;
  return 0;
&#125;
</code></pre>
<pre class=" language-lang-shell"><code class="language-lang-shell">$ time ./a.out  > cnt    //应用程序前加time可以统计一个程序的运行时间， > cnt 表示输出重定向到文件cnt 
...
real    0m1.082s
user    0m0.022s    // 程序在用户空间的时间
sys     0m0.986s    // 程序在内核空间的时间
</code></pre>
<h3 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer()"></a>setitimer()</h3><p>设置定时器，可替代alarm函数。精度微妙us。可以实现周期性定时。</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/time.h>
struct itimerval &#123;
    struct timeval it_interval; /* Interval for periodic timer 两次定时的间隔时间*/
    struct timeval it_value;    /* Time until next expiration 定时的时长*/
&#125;;
struct timeval &#123;
    time_t      tv_sec;         /* seconds */
    suseconds_t tv_usec;        /* microseconds */
&#125;;
int getitimer(int which, struct itimerval *curr_value);
int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);
</code></pre>
<p>参数：</p>
<ul>
<li><p>which：指定定时方式</p>
<ol>
<li>自然定时：ITIMER ==&gt; 14) SIGLARM                                                      计算自然时间</li>
<li>虚拟空间计时（用户空间）：ITIMER_VIRTUAL ==&gt; 26) SIGVTALRM  只计算进程占用cpu的时间</li>
<li>运行时计时（用户+内核）：ITIMER_PROF ==&gt; 27) SIGPROF              计算占用cpu和执行系统调用的时间</li>
</ol>
</li>
<li><p>new_value：定时的时间</p>
</li>
<li>old_value：上次定时剩余的时间</li>
</ul>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>

unsigned int my_alarm(unsigned int sec)
&#123;
  struct itimerval it, lastit;

  it.it_value.tv_sec = sec;
  it.it_value.tv_usec = 0;
  it.it_interval.tv_sec = 0;
  it.it_interval.tv_usec = 0;

  int ret = setitimer(ITIMER_REAL, &it, &lastit);
  if(ret == -1)
  &#123;
    perror("setitimer");
    exit(1);
  &#125;

  return lastit.it_value.tv_sec;

&#125;
int main(void)
&#123;
  my_alarm(1);
  for(int i = 0; ; i++)
  &#123;
    printf("%d \n", i);
  &#125;
  return 0;
&#125;
</code></pre>
<h2 id="3、信号捕捉函数"><a href="#3、信号捕捉函数" class="headerlink" title="3、信号捕捉函数"></a>3、信号捕捉函数</h2><h3 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
</code></pre>
<p>参数：signum，信号；handler，信号的回调函数，想让该信号进行的处理放这个回调函数里的。</p>
<p>返回值：成功返回信号处理程序的前一个值，失败返回SIG_ERR。</p>
<pre class=" language-lang-c"><code class="language-lang-c">#include <sys/time.h>
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

// 此函数运行在用户空间，由内核调用
// 函数返回时执行特殊的系统调用sigreturn再次进入内核
void func(int sigo)
&#123;
  printf("hello signal SIGALRM!\n");
&#125;
int main(void)
&#123;
  struct itimerval it, lastit;

  signal(SIGALRM, func); // 注册SIGALRM信号的捕捉处理函数

  it.it_value.tv_sec = 5;    //第一次定时5s
  it.it_value.tv_usec = 0;

  it.it_interval.tv_sec = 3;  // 后面都是定时3s
  it.it_interval.tv_usec = 0;

  int ret = setitimer(ITIMER_REAL, &it, &lastit);
  if(ret == -1)
  &#123;
    perror("setitimer");
    exit(1);
  &#125;

  while(1);
  return 0;
&#125;
</code></pre>
<h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction()"></a>sigaction()</h3><pre class=" language-lang-c"><code class="language-lang-c">#include <signal.h>
struct sigaction &#123;
    void     (*sa_handler)(int);  // 回调函数
    void     (*sa_sigaction)(int, siginfo_t *, void *); 
    sigset_t   sa_mask; // 信号捕捉函数期间的信号屏蔽字
    int        sa_flags;  
    void     (*sa_restorer)(void); // 已废弃，不看
&#125;;

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
</code></pre>
<p>sa_restorer：已过时，不应该使用。POSIX.1标准将不指定该元素。（弃用）</p>
<p>sa_sigaction：当sa_flags被指定为SA_SIGINFO标志时，使用该信号处理程序。（很少用）</p>
<p>重点：</p>
<p>sa_handler：指定该信号捕捉后的处理函数名（即注册函数）。也可以赋值为SIG_IGN表示忽略 或 SIG_DFL 表示执行默认动作。</p>
<p>sa_mask：调用信号处理函数时，所要屏蔽的信号集合（信号屏蔽字）。<strong>注意：仅在处理函数被调用期间屏蔽生效，是临时设置</strong>。</p>
<p>sa_flags：一般设置为0，表示使用默认属性。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
void catchsig(int signo)
&#123;
    printf(&quot;%d signal is catched\n&quot;,signo);
&#125;

int main(void)
&#123;
    int ret;
    struct sigaction act;

    act.sa_handler = catchsig;
    sigemptyset(&amp;act.sa_mask);
    sigaddset(&amp;act.sa_mask, SIGQUIT); //  3) SIGQUIT (ctr + \)
    act.sa_flags = 0; // 默认属性 信号捕捉函数执行期间，自动屏蔽本信号

    ret = sigaction(SIGINT, &amp;act, NULL); // 2) SIGINT(ctrl + c)
    if(ret &lt; 0)
    &#123;
        perror(&quot;sigaction error&quot;);
        exit(1);
    &#125;
    while(1);
    return 0;
&#125;
</code></pre><h2 id="4、信号集操作函数"><a href="#4、信号集操作函数" class="headerlink" title="4、信号集操作函数"></a>4、信号集操作函数</h2><p>内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字mask可以影响未决信号集。所以可以通过在应用程序中自定义set来改变mask，从而屏蔽指定信号。</p>
<h3 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a>信号集设定</h3><p>sigset_t    set;    // typdef unsigned long sigset_t; 本质上是位图    </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>int sigemptyset(sigset_t *set);</td>
<td>将某个信号集清零</td>
<td>成功：0；失败：-1</td>
</tr>
<tr>
<td>int sigfillset(sigset_t *set);</td>
<td>将某个信号集置1</td>
<td>成功：0；失败：-1</td>
</tr>
<tr>
<td>int sigaddset(sigset_t set, int signum);</td>
<td>将某个信号加入信号集</td>
<td>成功：0；失败：-1</td>
</tr>
<tr>
<td>int sigdelset(sigset_t set, int signum);</td>
<td>将某个信号清出信号集</td>
<td>成功：0；失败：-1</td>
</tr>
<tr>
<td>int sigismember(const sigset_t *set, int signum);</td>
<td>判断某个信号是否在信号集中</td>
<td>在集合：1；不在：0；出错：-1</td>
</tr>
</tbody>
</table>
</div>
<h3 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h3><p>用来<strong>屏蔽信号</strong>、<strong>解除信号屏蔽</strong>。其本质，读取或者修改进程的信号屏蔽字（pcb中）。</p>
<p><strong>再说一遍，屏蔽信号：只是将信号处理延后执行（延至解除屏蔽）；而忽略表示将信号丢弃。</strong></p>
<p>int sigprocmask(int how, const sigset_t <em>set, sigset_t </em>oldset);    成功：0；失败：-1，设置errno。</p>
<p>参数：</p>
<p>set：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽那个信号。</p>
<p>oldset：传出参数，保存旧的信号屏蔽字。</p>
<p>how：假定当前信号屏蔽字为mask</p>
<ol>
<li>SIG_BLOCK：set表示需要屏蔽的信号，相当 mask |= set</li>
<li>SIG_UNBLOCK：set表示需要解除屏蔽的信号，相当 mask = mask &amp; (~set)</li>
<li>SIG_SETMASK：set用于替代原始屏蔽集的新屏蔽集，相当 mask = set，若调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</li>
</ol>
<h3 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h3><p>读取当前进程的未决信号集。</p>
<p>int sigpending(sigset_t *set);    set：传出参数    返回值：成功：0；失败：-1，设置errno</p>
<pre class=" language-lang-c"><code class="language-lang-c">// 打印当前进程所有的未决信号集
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
void printpend(sigset_t *ped)
&#123;
    int i;
    for(i = 1; i < 32; i++)
    &#123;
        if(sigismember(ped, i) == 1)
        &#123;
            putchar('1');
        &#125;
        else
        &#123;
            putchar('0');
        &#125;
    &#125;
    printf("\n");
&#125;
int main(void)
&#123;
    sigset_t myset, oldset, ped;

    sigemptyset(&myset);  // 清零

    sigaddset(&myset, SIGQUIT); // 将 3) SIGQUIT(ctrl + \) 信号加入到myset信号集
    sigaddset(&myset, SIGINT); // 2) SIGINT(ctrl + c)
    sigaddset(&myset, SIGTSTP); // 20) SIGTSTP(ctrl +z)

    // 9)SIGKILL、19)SIGSTOP信号，不允许忽略或者捕获，只能执行默认动作。甚至不能将其阻塞。
    // 所以下面这两句其实没什么用
    sigaddset(&myset, SIGKILL);
    sigaddset(&myset, SIGSTOP);


    sigprocmask(SIG_BLOCK, &myset, &oldset); // 将myset信号集去影响阻塞信号集

    while(1)&#123;
        sigpending(&ped); // 获取当前进程的未决信号集。
           printpend(&ped);
        sleep(1);
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="5、信号捕捉特性"><a href="#5、信号捕捉特性" class="headerlink" title="5、信号捕捉特性"></a>5、信号捕捉特性</h2><ol>
<li>进程正常运行时，默认PCB中有一个信号屏蔽字，假定为⭐，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号后，要调用该函数。而该函数可能会执行很长时间，在这期间所屏蔽的信号不由⭐来指定，而是由sa_mask来指定。调用完信号处理函数，再恢复为⭐。</li>
<li>xxx信号捕捉函数执行期间，xxx信号自动屏蔽。</li>
<li>阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）</li>
</ol>
<h2 id="6、内核实现信号捕捉过程"><a href="#6、内核实现信号捕捉过程" class="headerlink" title="6、内核实现信号捕捉过程"></a>6、内核实现信号捕捉过程</h2><p><img src="https://i.loli.net/2021/07/05/hFPQlETXJvb3zHe.png" alt="内核实现信号捕捉过程.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title>SonarQube 代码扫描工具</title>
    <url>/2022/09/24/sonarQube/</url>
    <content><![CDATA[<h1 id="SonarQube"><a href="#SonarQube" class="headerlink" title="SonarQube"></a>SonarQube</h1><ul>
<li>最近工作中，领导一直想让我把部门的代码质量这块的工作搞起来，因为部门里的现在的工程师都是各自为战，代码风格各异，代码的漏洞问题也没有一个统一的工具去检查，甚至有些工程师都不会去做这一块的工作，只有真正出问题的时候才会去重视。</li>
<li>我在网上找了一圈，最终确定一款比较好的工具，那就是SonarQube。<h2 id="1、SonarQube"><a href="#1、SonarQube" class="headerlink" title="1、SonarQube"></a>1、SonarQube</h2></li>
<li>SonarQube是一款代码质量检测工具，基本版本是开源的，操作简单，支持cppcheck插件，还有web可视化的界面，还支持可持续化基础CI。</li>
<li>可以通过配置的代码分析规则，从可靠性、安全性、可维护性、覆盖率、重复率等方面分析项目，风险等级从A~E划分为5个等级。</li>
<li>sonar设置了质量门，通过设置的质量门评定此次提交分析的项目代码是否达到了规定的要求。</li>
</ul>
<h2 id="2、SonarQube-一般工作流程"><a href="#2、SonarQube-一般工作流程" class="headerlink" title="2、SonarQube 一般工作流程"></a>2、SonarQube 一般工作流程</h2><ul>
<li>1、开发人员在其IDE中进行编码，并使用SonarLint运行本地分析。</li>
<li>2、开发人员将其代码推送到他们最喜欢的SCM中：git，SVN，TFVC等。</li>
<li>3、Continuous Integration Server会触发自动构建，并执行运行SonarQube分析所需的SonarScanner。</li>
<li>4、分析报告将发送到SonarQube服务器进行处理。<br>SonarQube Server处理分析报告结果并将其存储在SonarQube数据库中，并在UI中显示结果。</li>
<li>5、开发人员通过SonarQube UI审查，评论，挑战他们的问题，以管理和减少技术债务。</li>
<li>6、经理从分析中接收报告。Ops使用API​​自动执行配置并从SonarQube提取数据。运维人员使用JMX监视SonarQube Server。</li>
</ul>
<h2 id="2、SonarQube-实际项目部署"><a href="#2、SonarQube-实际项目部署" class="headerlink" title="2、SonarQube 实际项目部署"></a>2、SonarQube 实际项目部署</h2><ul>
<li>待填坑。。。</li>
</ul>
]]></content>
      <categories>
        <category>代码扫描工具</category>
      </categories>
      <tags>
        <tag>代码质量</tag>
        <tag>c/c++</tag>
        <tag>代码检查工具</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程</title>
    <url>/2021/06/25/threadDescription/</url>
    <content><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><hr>
<h3 id="1、什么是进程、线程"><a href="#1、什么是进程、线程" class="headerlink" title="1、什么是进程、线程"></a>1、什么是进程、线程</h3><p>进程是一个程序被加载到内存执行的过程，它是一个动态的概念。线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元。进程是操作系统分配资源的最小单位，线程是操作系统调度执行的最小单位。打个比喻，操作系统是好像一个大工厂，工厂里面的一条条流水线就是一个个的进程，然后流水线上的工人负责整个流水作业的全部或者一小部分，这就叫线程。进程是真正的“打工人”，干活的实体。</p>
<hr>
<h3 id="2、进程和线程的区别"><a href="#2、进程和线程的区别" class="headerlink" title="2、进程和线程的区别"></a>2、进程和线程的区别</h3><ul>
<li>进程有自己独立的地址空间（每个进程都有拥有4GBytes的虚拟地址空间），多个线程共用同一个地址空间。</li>
<li>同一进程内的每个线程共享代码段(.text)，堆区(heap)，全局数据区(.data.bss)，文件描述符表。</li>
<li>同一进程内的每个线程独享自己的栈、寄存器。</li>
</ul>
<hr>
<h3 id="3、进程线程的特点"><a href="#3、进程线程的特点" class="headerlink" title="3、进程线程的特点"></a>3、进程线程的特点</h3><ul>
<li><p>进程</p>
<ul>
<li>进程拥有自己的地址空间，各进程间相互独立，一个进程挂死，不会影响到其他进程。</li>
</ul>
</li>
<li><p>线程</p>
<ul>
<li><p>线程占更小的系统资源，线程的上下文切换比进程要快的多。</p>
<blockquote>
<p>上下文切换：进程 / 线程分时复用 CPU 时间片，在切换之前会将上一个任务的状态进行保存，下次切换回这个任务的时候，加载这个状态继续运行，任务从保存到再次加载这个过程就是一次上下文切换。</p>
</blockquote>
</li>
<li><p>线程启动速度快，退出也快，对系统资源的冲击小。</p>
</li>
<li><p>一个进程内的某一个线程挂掉，那么整个进程就会挂掉。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4、进程间的通讯方式"><a href="#4、进程间的通讯方式" class="headerlink" title="4、进程间的通讯方式"></a>4、进程间的通讯方式</h3><ol>
<li>管道pipe。半双工，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，常见于父子进程。</li>
<li>有名管道FIFO。半双工，数据只能单向流动，允许无亲缘关系进程间的通信。</li>
<li>消息队列MessageQueue。消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问，防止多进程访问共享资源时产生竞争。是进程同步的一种手段。</li>
<li>套接字Socket：用于不同机器间的进程通信，网络通信少不了它。</li>
<li>信号 Signal： 段错误、kill -9 的时候就是这种信号。</li>
</ol>
<hr>
<h3 id="5、线程间通信方式"><a href="#5、线程间通信方式" class="headerlink" title="5、线程间通信方式"></a>5、线程间通信方式</h3><blockquote>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
</blockquote>
<ol>
<li>锁机制：包括互斥锁、条件变量、读写锁。<ul>
<li>互斥锁提供了以排他方式防止数据结构被并发修改的方法，常用于多线程间对共享资源的访问保护。</li>
<li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
</li>
<li>信号量机制(Semaphore)：信号量既是是进程同步的一种手段，也是线程同步的一种手段。</li>
<li>信号机制(Signal)：类似进程间的信号处理。线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</li>
</ol>
]]></content>
      <categories>
        <category>线程进程</category>
      </categories>
      <tags>
        <tag>线程进程</tag>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
</search>
